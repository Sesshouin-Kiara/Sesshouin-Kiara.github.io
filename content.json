{"pages":[{"title":"关于","text":"也尝试过花里胡哨发现背驰了写技术博客的初衷记录技术，展示生活，才是写博客的初心简洁、突出文字输出，是主题的格调 介绍 基于百度编程 人的梦想，是不会终结的 联系方式 QQ：406166751 微信：wh406166751 邮箱：ssyqihuang@gmail.com; wanghong124@qq.com 本文作者：WangHong 永久链接：wanghong.cool 版权声明：本网站所有博文均首发于WangHong的博客，转载请注明出处！","link":"/about/index.html"}],"posts":[{"title":"数字保留两位小数及toFixed的bug带来的思考","text":"把数字保留两位小数，可以直接使用toFixed。 123let a = 2.335let num1 = a.toFixed(2)console.log(num1) 但是toFixed并不是真正意义上的四舍五入，很多大神的解释如下： toFixed() 方法可把 Number 四舍五入为指定小数位数的数字。例如将数据Num保留2位小数，则表示为：toFixed(2)；但是其四舍五入的规则与数学中的规则不同，使用的是银行家舍入规则，银行家舍入：所谓银行家舍入法，其实质是一种四舍六入五取偶（又称四舍六入五留双）法。具体规则如下： 简单来说就是：四舍六入五考虑，五后非零就进一，五后为零看奇偶，五前为偶应舍去，五前为奇要进一。不过，实际上我自己的测试结果与上述规则不符，有时候是五前为偶进一，五前为奇舍去，不知道哪里的问题（可以F12打开 开发者调试工具进行测试）。例如： 2.305.toFixed(2) = 2.31不符合，偶进一 2.315.toFixed(2) = 2.31不符合，奇舍去 2.325.toFixed(2) = 2.33不符合，偶进一 2.335.toFixed(2) = 2.33不符合，奇舍去 2.345.toFixed(2) = 2.35不符合，偶进一 2.355.toFixed(2) = 2.35不符合，奇舍去 2.365.toFixed(2) = 2.37不符合，偶进一 2.375.toFixed(2) = 2.38符合，奇进一 2.385.toFixed(2) = 2.38符合，奇舍去 2.395.toFixed(2) = 2.40符合，奇进一 2.3开头时会出现这种异常状况，2.4/2.5开头又正常了，2.6/2.7/2.8又不正常了，等等等等。 百度搜索“银行家舍入算法”、“toFixed”之类的关键词，甚至还有很大一部分搜索靠前的帖子博文中的 toFixed 算出来的结果都是错的（即我用F12调试得出来的结果和作者在文中写的结果不一致），让我怀疑他们是不是复制粘贴，根本没有试过结果的正确与否。 我不知道为什么会出现这种问题，首先我感觉是不是我对银行家舍入规则理解错了，不过后来仔细看了一下银行家舍入规则，发现并没有错误，确实是五前为偶应舍去，五前为奇要进一。 那难道是 toFixed 其实并没有使用银行家舍入规则？我看了下 W3school 和 MDN Web Docs，都只是很简洁的说了句 toFixed 功能是四舍五入，并没有深入提及其他的东西。 从结果来看，toFixed很明显不是四舍五入，也不是四舍六入五考虑，那么 toFixed 到底采用的是什么算法呢？ 突然想起以前也遇到过一些number类型的问题，最后发现是js的精度导致的，那么这里会不会也是精度的问题呢？ 这是之前不符合银行家舍入规则的两组数据： 2.305.toFixed(2) = 2.31不符合，偶进一 2.315.toFixed(2) = 2.31不符合，奇舍去 将两组数据的精度提升到20位，得到如下结果： 2.305.toFixed(20) = 2.30500000000000015987 2.315.toFixed(20) = 2.31499999999999994671 果然出现问题了，可以发现，将2.305精度提高后，发现得到了一个略大于2.305的值，而2.315得到了一个略小于2.315的值。 提升精度后，值却改变了，这说明原先的我输入的2.305本身就不是真正意义上的2.305，而是一个略大的近似值，可以这样证明（在开发者工具中进行调试）： 打印2.toFixed(20)，输出2.00000000000000000000，说明2的值至少20位精度时是精确的。 打印2.305-2，输出0.30500000000000016，该值大于0.305，说明输入的2.305确实是一个比真正的2.305大的数字。 可以得出结论了： toFixed 采用的确实是银行家舍入规则，但是由于js精度带来的误差，导致我们看到了一些不符合银行家舍入规则的数据。 至于为何会出现精度问题，这就涉及到一些底层知识了，本文不做探讨，可以参考这篇文章。 不过，不管是四舍六入五考虑，还是精度带来的误差，都不符合我们一般情况下数据处理的方式，即四舍五入。为了解决这样的问题，可以使用Math.round方法实现指定保留任意位数据。 1let num2= (Math.round(a * 100) / 100).toFixed(2) Math.round()方法可把一个数字舍入为最接近的整数。其取舍的方法使用的是四舍五入，符合数学中取舍的规则。对于小数的处理没有那么便捷，但是可以根据不同的要求，进行自定义的处理。 例如：对于X进行保留两位小数的处理，则可以使用Math.round(X*100)/100进行处理。 2.355.toFixed(2) = 2.35 Math.round(2.355 * 100) / 100 = 2.36 有时候原数据位数不够，需要补齐位数，可以round 和 toFixed一起使用： (Math.round(1.5 * 100) / 100).toFixed(2) = 1.50 终极解决方案如下：(Math.round(number*10digit)/10digit).toFixed(digit) number：需要进行舍入操作的数据digit：保留的位数","link":"/2020/01/08/blog10/"},{"title":"从零开始搭建后台管理系统（二）Vue Router","text":"本项目基于 Vue全家桶 和 Ant Design 进行开发。 目录 安装脚手架工具（vue-cli）、创建新项目 引入 Ant Design 引入 Vue Router 引入 node-sass/sass-loader 登录页 完成页面的基本布局（ 根据路由渲染菜单组件、面包屑组件等 ） 使用 Vuex 完成菜单的显示隐藏 Ajax 以及 Axios 的封装 全局方法 Utils、混合 Mixins 后续功能开发 6.完成页面的基本布局App.vue中有一个&lt;router-view /&gt;标签作为路由的出口，这个出口可以用来匹配 Login 页 等不需要菜单、头部、面包屑、底部等公用组件的页面。但是对于菜单里面的功能页，每个页面都需要这些公用组件，如果用这个路由出口来匹配这些功能页的话，每个功能页都需要写入这些公用组件，显得十分臃肿。因此我们需要创建一个main.vue文件，来完成功能页面的布局（包括菜单、头部、底部组件以及显示页面对应功能内容的区域），并且在main.vue中再提供一个&lt;router-view /&gt;标签，作为功能页面路由的出口，用来显示所有需要用到菜单等组件的功能页面。 在 views 目录下创建main.vue文件。 在 components 目录下创建aside（侧边菜单）、breadcrumb（面包屑）、header（头部）3个组件文件； 在 views 目录下创建account（账号）、department（部门）、setting（设置）3个功能页面的文件夹。 把新页面添加进router.js router.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142import Vue from 'vue'import VueRouter from 'vue-router'// 引入（路由）组件// 基本布局Main页面import Main from './views/main'import Login from './views/login.vue'import Home from './views/home'//账号管理import Account from './views/account'//部门管理import FrontEnd from './views/department/front-end'import BackEnd from './views/department/back-end'//设置import Setting from './views/setting'// 告诉 Vue 使用 VueRouterVue.use(VueRouter)// 定义路由routerconst router = new VueRouter({ routes: [ { path: '/', redirect: { name: \"login\" } }, { path: '*', redirect: { name: \"login\" } }, { path: '/login', name: 'login', component: Login, meta: { name: '登录' } }, { path: '/home', name: 'home', component: Main, meta: { name: '首页' }, redirect: { name: 'homeIndex' }, children: [ { path: 'index', name: 'homeIndex', meta: { name: '首页', auth: true, }, component: Home } ] }, { path: '/account', name: 'account', component: Main, meta: { name: '账号管理' }, redirect: { name: 'accountIndex' }, children: [ { path: 'index', name: 'accountIndex', meta: { name: '账号列表', auth: true, }, component: Account } ] }, { path: '/department', name: 'department', component: Main, meta: { name: '部门管理' }, redirect: { name: \"front-end\" }, children: [ { path: 'front-end', name: 'front-end', component: FrontEnd, meta: { name: '前端开发部' } }, { path: 'back-end', name: 'back-end', component: BackEnd, meta: { name: '后端开发部' } } ] }, { path: '/setting', name: 'setting', component: Main, meta: { name: '设置' }, redirect: { name: 'settingIndex' }, children: [ { path: 'index', name: 'settingIndex', meta: { name: '设置', auth: true, }, component: Setting } ] }, ]});// 将router暴露出去供其他文件使用export default router; aside.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;template&gt; &lt;div class=\"myAside\"&gt; &lt;div class=\"logo\"&gt;阿里巴巴后台管理系统&lt;/div&gt; &lt;!-- 菜单组件 --&gt; &lt;a-menu :defaultSelectedKeys=\"selectedKeys\" mode=\"inline\" theme=\"dark\" :openKeys.sync=\"openKeys\" &gt; &lt;template v-for=\"item in routeData\"&gt; &lt;!-- 有children的路由 --&gt; &lt;a-sub-menu :key=\"item.name\" v-if=\"item.children\" &gt; &lt;span slot=\"title\"&gt; &lt;span&gt;{{item.meta.name}}&lt;/span&gt; &lt;/span&gt; &lt;template v-for=\"childrenItem in item.children\"&gt; &lt;a-menu-item :key=\"childrenItem.name\" @click=\"gotoRoute(childrenItem.name)\" &gt;{{childrenItem.meta.name}}&lt;/a-menu-item&gt; &lt;/template&gt; &lt;/a-sub-menu&gt; &lt;!-- 无children的路由 --&gt; &lt;a-menu-item :key=\"item.name\" @click=\"gotoRoute(item.name)\" v-else &gt; &lt;span&gt;{{item.meta.name}}&lt;/span&gt; &lt;/a-menu-item&gt; &lt;/template&gt; &lt;/a-menu&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { data() { return { routeData: [], selectedKeys: [], openKeys: [], }; }, created() { this.getMenuData() }, methods: { // 根据路由渲染菜单 getMenuData() { //菜单项 this.routeData = [] let deepCloneRouteData = JSON.parse(JSON.stringify(this.$router.options.routes)) // console.log(this.$router.history.current.name) deepCloneRouteData.forEach((val, index) =&gt; { if ((val.path !== '/') &amp;&amp; (val.path !== '*') &amp;&amp; (val.path !== '/login')) { this.routeData.push(val) } }) //默认选中项 this.selectedKeys = [this.$router.history.current.name] //展开的子路由选中项 this.openKeys = [] this.openKeys = ['ios'] }, gotoRoute(name) { this.$router.push({ name: name }) } } }&lt;/script&gt;&lt;style lang=\"scss\"&gt; .myAside { min-height: 100vh; //使菜单高度填满屏幕 background-color: #001529; .menuBtn { position: fixed; top: 10px; left: 260px; z-index: 999; } .logo { width: 256px; height: 60px; background-color: #001529; font-size: 16px; font-weight: 500; line-height: 60px; text-align: center; color: white; } }&lt;/style&gt; breadcrumb.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;template&gt; &lt;div class=\"myBreadCurmb\"&gt; &lt;a-breadcrumb&gt; &lt;a-breadcrumb-item :key=\"index\" v-for=\"(item,index) in path\" &gt;{{item}}&lt;/a-breadcrumb-item&gt; &lt;/a-breadcrumb&gt; &lt;div class=\"title\"&gt;{{title}}&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { data() { return { title: '', path: [] }; }, created() { this.setTitleAndPath() }, watch: { $route(to, from) { this.setTitleAndPath() } }, methods: { setTitleAndPath() { this.title = this.$router.history.current.meta.name this.path = [] this.$router.history.current.matched.forEach((val, index) =&gt; { this.path.push(val.meta.name) }); } } }&lt;/script&gt;&lt;style lang=\"scss\"&gt; .myBreadCurmb { padding: 16px 32px; margin-top: 3px; background-color: white; .title { font-size: 26px; font-weight: 600; color: black; margin-top: 16px; } }&lt;/style&gt; main.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;template&gt; &lt;div class=\"myMain\"&gt; &lt;Aside&gt;&lt;/Aside&gt; &lt;div class=\"right\"&gt; &lt;Header&gt;&lt;/Header&gt; &lt;Breadcrumb&gt;&lt;/Breadcrumb&gt; &lt;div class=\"content\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;Copyright © 2020 alibaba&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; import Aside from '../components/aside' import Header from '../components/header' import Breadcrumb from '../components/breadcrumb' export default { data() { return { }; }, components: { Aside, Header, Breadcrumb }, computed: {}, created() { }, methods: {} } &lt;/script&gt; &lt;style lang=\"scss\"&gt; .myMain { display: flex; flex-direction: row; .right { flex: 1; display: flex; flex-direction: column; .content { padding: 24px 24px 0 24px; flex: 1; //头部和底部组件高度确定，整体min-height又等于100vh（aside高度），所以内容区填满剩余的高度 } .footer { height: 76px; line-height: 76px; text-align: center; font-size: 12px; color: #aaa; } } }&lt;/style&gt; 基本的页面布局和路由已经搭建好了，我们看看效果： 不过出现了一个小问题，我们使用main.vue来布局，使用Main的子路由来显示功能页的内容，这样导致 首页、设置 等只需要一级路由的模块有了两层路由，菜单中也出现了两级菜单，这不是我们期望的。 解决方案：我们在路由元信息meta中添加一个unfold字段来表示该项路由对应菜单的是否能展开，为 true 时表示该项菜单可以展开。 router.js123456789101112131415{ path: '/department', name: 'department', component: Main, meta: { name: '部门管理', unfold: true // + }, redirect: { name: \"front-end\" }, children: [ //... ]}, aside组件中，菜单能否展开的判断条件从 是否有子路由children改成 路由元信息中的unfold字段是否存在且为true。 aside.vue12345&lt;!-- 有children的路由 --&gt;&lt;a-sub-menu :key=\"item.name\" v-if=\"item.meta.unfold\"&gt; 修改后效果就比较符合原来的预期了：","link":"/2020/03/14/blog14/"},{"title":"文字超过部分显示省略号","text":"有两种情况，超过一行和超过多行时剩余部分显示省略号： 标题超过一行时，超过宽度的部分用省略号代替 文本超过（若干）行时，超过这几行的部分用省略号代替 下面是两个例子： 情况一：写一个招聘模块时遇到了如下问题，职位名称太长以至于影响了页面布局，这时需要隐藏职位名称超出的部分。修改之前: 123.jobName { width: 50%;} 修改之后: 123456.jobName { width: 50%; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;} 情况二：审批意见超过两行时，多余部分隐藏并显示省略号和展开按钮，点击可查看全部。效果如图： 文本不做任何处理，自然展开时的css： 123456.content { font-size: 24px; line-height: 40px; color: rgba(0, 0, 0, 0.65); width: 410px;} 文本收起时，在content类基础上再添加一个content_hidden类： 1234567.content_hidden { overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2;}","link":"/2020/03/05/blog11/"},{"title":"js实现引用类型的深拷贝","text":"var deepCloneObj = JSON.parse(JSON.stringify(obj)) 为什么要使用深拷贝？我们希望得到一个新的引用类型的变量（数组、对象），并且在修改这个引用类型变量的时候，不改变原数组（对象）的值。 引用类型保存的值只是一个地址，浅拷贝会让两个变量指向同一块空间，从而让拷贝对象和源对象互相影响。我们从拷贝普通类型的变量知道，拷贝一个字符串会开辟一个新的存储地址，这样就切断了引用对象的指针联系。 12345678910let obj = { name: 'Boa Hancock', age: 31, gender: 'female'}var deepCloneObj = JSON.parse(JSON.stringify(obj));//拷贝对象console.log('obj:',obj)console.log('deepCloneObj:',deepCloneObj) 打印结果如下,两个对象的值是一样的： 修改新对象的值： 1234deepCloneObj.name = 'Sesshouin Kiara'console.log('obj:',obj)console.log('deepCloneObj:',deepCloneObj) 打印结果如下： 新对象的name属性改变了，但是并没有影响到原对象name属性的值，这说明新对象和旧对象指向不同的存储空间，拷贝完成。 但是这种方式也是有局限性的，当源对象中有函数、undefined、null、NaN、正则等一些属性时，拷贝会失败。","link":"/2019/12/22/blog1/"},{"title":"在微信公众号中使用微信支付","text":"以前做过微信小程序的支付，但是小程序的环境是微信内部提供的,能使用一些微信官方提供的便利的API，而公众号其实是普通的H5网页，两者在代码层面还是有差别的。 微信支付流程图 前提：公众号需要在微信公众平台中开通支付功能。 第一步：进入页面时对页面进行重定向，获取code12345678910111213141516export function redirectPage(path) { let appid = \"wxa2b43f80deee74aa\"; const url = `http://ylhtest.adt100.com${path}`; console.log(url); console.log(window.location.href); if (window.location.href.includes(\"code\")) { // 包含就不需要重定向 只需要获取code console.log(getQueryString(\"code\")); return getQueryString(\"code\"); } else { // 对页面进行重定向 以便获取code window.location.href = `https://open.weixin.qq.com/connect/oauth2/authorize?appid=${appid}&amp;redirect_uri=${url}&amp;response_type=code&amp;scope=snsapi_base&amp;state=STATE`; console.log(window.location.href); return \"\"; }} 第二步：获取code之后，调用后端接口获取openid12345678910111213141516171819202122export function getOpenid(code) { return dispatch =&gt; { alert(2222); axios({ method: \"get\", url: global.url.GET_OPENID, params: { code: code, appId: \"wxa2b43f80deee74aa\" } }) .then(res =&gt; { console.log(res); if (res.data.code === 200) { dispatch(wxOpenid(res.data.data)); } }) .catch(err =&gt; { console.log(\"openid获取错误\"); }); };} 第三步：获取支付相关字段信息（商品id、价格 等）和openid，传给后端去进行统一下单和生成签名等操作。这些操作完成后，后端会返回前端调用支付接口所需要的数据，数据结构基本如下：1234567891011\"data\": { \"orderNo\": \"\", //订单编号 \"res\": { \"appId\" : \"wx2421b1c4370ec43b\", //公众号名称，由商户传入 \"timeStamp\":\"1395712654\", //时间戳，自1970年以来的秒数 \"nonceStr\" : \"e61463f8efa94090b1f366cccfbbb444\", //随机串 \"package\" : \"prepay_id=u802345jgfjsdfgsdg888\", \"signType\" : \"MD5\", //微信签名方式： \"paySign\" : \"70EA570631E4BB79628FBCA90534C63FF7FADD89\" //微信签名 }}, 第四步：使用上述参数，调用微信的JSAPI接口请求支付。12345678910if (typeof WeixinJSBridge == \"undefined\") { if (document.addEventListener) { document.addEventListener('WeixinJSBridgeReady', this.onBridgeReady(res),false); } else if (document.attachEvent) { document.attachEvent('WeixinJSBridgeReady', this.onBridgeReady(res)); document.attachEvent('onWeixinJSBridgeReady', this.onBridgeReady(res)); }} else { this.onBridgeReady(res);} 1234567891011121314151617181920212223onBridgeReady(res) { const { appId, timeStamp, nonceStr, package, paySign } = res; WeixinJSBridge.invoke( 'getBrandWCPayRequest', { \"appId\" : appId, //公众号名称，由商户传入 \"timeStamp\":timeStamp, //时间戳，自1970年以来的秒数 \"nonceStr\" : nonceStr, //随机串 \"package\" : package, \"signType\" : \"MD5\", //微信签名方式： \"paySign\" : paySign //微信签名 }, (res) =&gt; { if(res.err_msg == \"get_brand_wcpay_request:ok\"){ console.log(\"success\"); // 使用以上方式判断前端返回,微信团队郑重提示： // res.err_msg将在用户支付成功后返回ok，但并不保证它绝对可靠。 }else{ console.log(\"fail\"); } } )}, 注意： WeixinJSBridge内置对象仅在手机端微信的浏览器中存在，在其他浏览器中无效。 微信支付文档表示，JS API的返回结果 get_brand_wcpay_request:ok 仅在用户成功完成支付时返回。由于前端交互复杂， get_brand_wcpay_request:cancel 或者 get_brand_wcpay_request:fail 可以统一处理为用户遇到错误或者主动放弃，不必细化区分 结果：第二步客户端发起支付请求后，微信会验证参数和环境的合法性，验证通过后弹出输入支付密码页面，用户输入密码完成支付。微信会根据实际情况通知商户后台和客户端支付结果【根据返回的信息选择进入成功回调还是失败回调，取消支付同样进入失败（cancel）回调】。 总结：公众号和小程序的支付流程基本一致，不过由于环境的差异导致代码层面有些不同，例如小程序中，支付是直接调用wx.requestPayment接口，openid也可以直接通过wx的api拿到。","link":"/2020/03/11/blog12/"},{"title":"从零开始搭建后台管理系统（一）准备工作","text":"本项目基于 Vue全家桶 和 Ant Design 进行开发。 目录 安装脚手架工具（vue-cli）、创建新项目 引入 Ant Design 引入 Vue Router 引入 node-sass/sass-loader 登录页 完成页面的基本布局（ 根据路由渲染菜单组件、面包屑组件等 ） 使用 Vuex 完成菜单的显示隐藏 Ajax 以及 Axios 的封装 全局方法 Utils、混合 Mixins 后续功能开发 tips： npm下载速度慢可使用 cnpm 或 yarn。 安装各种插件过程中项目可能会报缺少一些依赖之类的错误，安装这些依赖包后仍然报错，大概率是node包版本的问题，建议百度。 eslint有点烦，不想配置的话新建项目的时候 eslint 选择 no 创建项目安装脚手架工具123$ npm install -g @vue/cli# OR$ yarn global add @vue/cli 创建新项目1vue create antd-demo 引入Ant Design安装antd1$ npm i --save ant-design-vue 按需引入等操作移步Ant Design of Vue 快速上手 文档查看 安装路由（从零开始使用Vue Router）安装路由之前，我们可以在src目录下新建views和components两个文件夹，来存放项目需要用到的页面和组件。安装好之后，在src目录下新建一个router.js文件，记得配置好路径为空或者不存在时的映射（一般是跳转到首页或登录页）。router.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546import Vue from 'vue'import VueRouter from 'vue-router'// 引入（路由）组件import Login from './views/login.vue'import Home from './views/home.vue'// 告诉 Vue 使用 VueRouterVue.use(VueRouter)// 定义路由routerconst router = new VueRouter({ routes: [ { path: '/', redirect: { name: \"login\" } }, { path: '*', redirect: { name: \"login\" } }, { path: '/login', name: 'login', component: Login, meta:{ name:'登录' } }, { path: '/home', name: 'home', component: Home, meta:{ name:'首页' } }, ]});// 将router暴露出去供其他文件使用export default router; 在main.js中引用router.jsmain.js12345678910import Vue from 'vue'import App from './App.vue' import router from './router' // +Vue.config.productionTip = falsenew Vue({ router, // + render: h =&gt; h(App),}).$mount('#app') App.vue中，添加一个&lt;router-view /&gt;标签作为路由的出口，我们可以通过进入不同的路由来显示不同的页面。App.vue123456789101112131415161718&lt;template&gt; &lt;div id=\"app\"&gt; &lt;router-view /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { name: 'App', components: { } }&lt;/script&gt;&lt;style&gt; #app { }&lt;/style&gt; 此时项目目录结构如图所示： 安装CSS预处理器（Scss） 1npm install sass-loader node-sass --save-dev 安装完css预处理器之后，我们就能写入如下格式的css代码了： 1234567891011121314151617181920212223.login { height: 100vh; position: relative; display: flex; flex-direction: column; align-items: center; padding-top: 26vh; background: #f0f3f7; .content { width: 368px; .title { text-align: center; margin-bottom: 24px; font-size: 24px; } .input { margin-bottom: 24px; } .btn { width: 100%; } }} 登录页写页面过程中会用到 Ant Design 的组件，引用方法如下： main.js123456789101112131415161718192021222324import Vue from 'vue'import App from './App.vue'import router from './router'import { Input, Button, Menu, Icon,} from 'ant-design-vue';// Vue.component和Vue.use这里作用都是注册组件// Vue.component(Input.name, Input);Vue.use(Input)Vue.use(Button)Vue.use(Menu)Vue.use(Icon)Vue.config.productionTip = falsenew Vue({ router, render: h =&gt; h(App),}).$mount('#app') 完成好登录页面：","link":"/2020/03/12/blog13/"},{"title":"从零开始搭建后台管理系统（四）Ajax、Axios","text":"本项目基于 Vue全家桶 和 Ant Design 进行开发。 目录 安装脚手架工具（vue-cli）、创建新项目 引入 Ant Design 引入 Vue Router 引入 node-sass/sass-loader 登录页 完成页面的基本布局（ 根据路由渲染菜单组件、面包屑组件等 ） 使用 Vuex 完成菜单的显示隐藏 Ajax 以及 Axios 的封装 全局方法 Utils、混合 Mixins 后续功能开发 8.Ajax 以及 Axios 的封装后台接口使用豆瓣提供的开放接口：获取top250电影：https://douban.uieee.com/v2/movie/top250 8.1. Ajax新建一个电影模块的页面，直接上代码： src/views/movie/top250.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;template&gt; &lt;div class=\"movie\"&gt; &lt;!-- rowKey不能少 --&gt; &lt;a-table :columns=\"columns\" :dataSource=\"data\" :rowKey=\"record =&gt; record.id\" bordered &gt; &lt;div slot=\"images\" slot-scope=\"text\" &gt; &lt;div style=\"height:120px;\"&gt; &lt;img :src=\"text.small\" alt=\"img\" style=\"height:100%;\" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div slot=\"rating\" slot-scope=\"text\" &gt;{{text.average}}&lt;/div&gt; &lt;div slot=\"durations\" slot-scope=\"text\" &gt;{{text[0]}}&lt;/div&gt; &lt;div slot=\"genres\" slot-scope=\"text\" &gt; &lt;a-tag :key=\"index\" color=\"cyan\" v-for=\"(tag,index) in text\" &gt;{{tag}}&lt;/a-tag&gt; &lt;/div&gt; &lt;div slot=\"action\" slot-scope=\"record\" &gt; &lt;a @click=\"delMovie(record.id)\" slot=\"action\" &gt;收藏&lt;/a&gt; &lt;span style=\"color:#eee;padding:0 4px;\"&gt;|&lt;/span&gt; &lt;a @click=\"delMovie(record.id)\" slot=\"action\" &gt;喜欢&lt;/a&gt; &lt;span style=\"color:#eee;padding:0 4px;\"&gt;|&lt;/span&gt; &lt;a @click=\"delMovie(record.id)\" slot=\"action\" &gt;删除&lt;/a&gt; &lt;/div&gt; &lt;/a-table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { data() { return { data: [], columns: [ { title: \"编号\", customRender: (text, record, index) =&gt; `${index + 1}` }, { title: '名称', dataIndex: 'title' }, { title: '海报', dataIndex: 'images', scopedSlots: { customRender: 'images' } }, { title: '评分', dataIndex: 'rating', scopedSlots: { customRender: 'rating' } }, { title: '时长', dataIndex: 'durations', scopedSlots: { customRender: 'durations' } }, { title: '标签', dataIndex: 'genres', scopedSlots: { customRender: 'genres' } }, { title: '年份', dataIndex: 'year' }, { title: '操作', fixed: 'right', width: 150, scopedSlots: { customRender: 'action' }, } ] }; }, created() { this.getList() }, methods: { getList() { //原生ajax let that = this var xhr = new XMLHttpRequest() xhr.onreadystatechange = function () { //异步回调，每当readyState改变的时候都会触发readystatechange事件 if (xhr.readyState == 4) { if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) { that.data = JSON.parse(xhr.responseText).subjects } else { console.log(\"Request was unsuccessful: \" + xhr.status); } } }; xhr.open(\"get\", \"https://douban.uieee.com/v2/movie/top250?count=30\", false); // 准备 xhr.send(null) // 发送 }, delMovie(id) { } } }&lt;/script&gt;&lt;style lang=\"scss\"&gt; .movie { // 基本布局 padding: 24px; background-color: white; min-height: 100%; }&lt;/style&gt; 以上是原生ajax的用法，先创建一个xhr对象，然后调用open()和send()方法发送请求。在readyState=4 的 readystatechange 事件回调中进行操作。 效果如下，成功拿到了豆瓣的数据： 使用豆瓣API的过程中发现了一个问题，管理系统请求到的图片资源在network中全部是403禁止访问，导致在网页中不能正常显示，但是把图片url放到浏览器中可以正常打开图片。 原因是豆瓣有防盗链，后台会根据请求头header里的Referrer属性来判断请求是不是来自一个白名单内的网站，如果不是就返回 403 forbidden。 解决方法如下，我们把Referrer信息去掉就好了。在index.html文件中添加一个&lt;meta name=”referrer” content=”never”&gt;标签。( 不过按照我的使用经验来说，像腾讯云之类的oss是可以配置必传Referrer信息的，但是很多网站没配置这个选项 ) 8.2. Axios接下来看看 Axios（查看文档） 的用法。安装： 1$ npm install axios 在需要用到axios的页面引入 top250.vue1234567891011import axios from \"axios\";//......getList() { //axios axios.get('https://douban.uieee.com/v2/movie/top250?count=30').then((response) =&gt; { console.log(response.data.subjects); this.data = response.data.subjects }).catch(function (error) { console.log(error); });}, 或者： top250.vue123456789101112131415import axios from \"axios\";//......getList() { // 上面的请求也可以这样写 axios.get('https://douban.uieee.com/v2/movie/top250', { params: { count: 30 } }).then((response) =&gt; { console.log(response.data.subjects); this.data = response.data.subjects }).catch(function (error) { console.log(error); });}, 我们不希望每个页面都去引入一次axios，更重要的是，实际开发中，接口通常会很多，需要分模块、系统地管理api，所以我们需要对axios进行封装。 8.3. 对 Axios 进行封装在src目录下新建axios.js文件，用来写axios的配置项和拦截器等。 在src目录下新建一个api文件夹: api / modules文件夹用来存放所有api模块； api / index.js文件用来统一封装ajax方法。 目录如下： src/axios.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import Vue from 'vue';import axios from \"axios\";import router from \"./router\";// import UserInfoTool from './user-info-tool';import { message as Message} from 'ant-design-vue';// 实际开发中需要根据不同的环境选择不同的api_baseUrl// const _domain = process.env.VUE_APP_API_URL;const _domain = 'https://douban.uieee.com';let config = { baseURL: _domain, timeout: 60 * 1000, // Timeout withCredentials: true, // Check cross-site Access-Control validateStatus: function (status) { return status &gt;= 200 &amp;&amp; status &lt; 500; // default },};const _axios = axios.create(config);// 添加请求拦截器_axios.interceptors.request.use( function (config) { // 在发送请求之前做些什么 // 如果登录存了token的话，在这里把token放入请求头 // let _token = UserInfoTool.getToken(); // if (_token) { // config.headers.authorization = _token; // } return config; }, function (error) { // 对请求错误做些什么 return Promise.reject(error); });// 添加响应拦截器_axios.interceptors.response.use( function (response) { // 对响应数据做点什么 if (/blob/i.test(response.config.responseType)) { // 如果是blob数据的话，返回全部response return response; } else if (response.status === 200) { // 如果响应头中携带authorization等信息，重置token // if (response.headers.authorization) { // UserInfoTool.setToken(response.headers.authorization); // } return response.data; } else if (response.status === 401) { Message.error('登录失效，请重新登录'); // 清除账号token信息，返回登录页面 // UserInfoTool.clear(); router.push({ path: '/login' }) return Promise.reject(new Error(response.msg)); } else { Message.error(response.msg); return Promise.reject(new Error(response.msg)); } }, function (error) { // 对响应错误做点什么 return Promise.reject(error); });Vue.prototype.$domain = _domain;Vue.prototype.$axios = _axios;Vue.prototype.$baseUrl = config.baseURL;export default _axios;export const domain = _domain; src/api/modules/movie.api.js1234567export default { getTop250: { method: 'GET', url: '/v2/movie/top250', name: '获取top250电影列表' },} src/api/index.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159/** * api 统一封装方法 * @description api集合为元数据，可直接在页面使用 this.$api[module][api]某某方法 * @example api.login.logout(queryOrBodyData, enableFilterEmpty) * * @param {Object} queryOrBodyData? 查询参数 或者 荷载数据 * @param {Boolean} enableFilterEmpty? 是否开启过滤空字段，默认 false * * @return {Object&lt;{ data }&gt;} */import { message as Message} from 'ant-design-vue';import axios, { domain} from '@/axios';// 引入api模块import movieApi from './modules/movie.api';// 合并所有模块api并导出到外部， 可直接在页面使用 this.$api.模块名.接口名const APIS = { movie: movieApi,};/** * 请求前 中间件 * @param apiMeta API元数据 * @param data 请求数据 */function foreRequestMiddleWare(apiMeta, data) { const { url, method, } = apiMeta; // 处理 /a/b/c/:id 接口 if (method.toUpperCase() === 'GET' || method.toUpperCase() === 'DELETE') { apiMeta.targetUrl = url.replace(/\\B:(\\w+)/g, (...args) =&gt; { apiMeta.resource = true; return data[args[1]]; }) } else { apiMeta.targetUrl = url; }};/** * 请求失败后 中间件 * @param {ApiMeta} apiMeta API元数据 * @param {Error} error 请求错误对象 * @param {Function} next 下一步 */function fallbackMiddleWare(apiMeta, error, next) { const { name, method, url, errorHandler } = apiMeta; console.error(`[${method}][${domain}${url}]: ${name} 失败，${error.message}`); if (errorHandler) { Message.error(`${name} 失败，${error.message}`); } next(error);}// 将单个模块的 meta 转换为 请求function Proxyable(target) { const target_ = {}; for (const key in target) { if (target.hasOwnProperty(key)) { target_[key] = ProxyApi(target, key); } } return target_;}// 将 ApiMeta 映射为 http 请求function ProxyApi(target, key) { if (!target[key]) throw new ReferenceError('API ' + key + ' not exist'); const { method, } = target[key]; if (method.toUpperCase() === 'GET') { return (query = { }, opt) =&gt; new Promise((resolve, reject) =&gt; { foreRequestMiddleWare(target[key], query); let promise = null; if (target[key].resource) { promise = axios.get(target[key].targetUrl, {}, opt) } else { promise = axios.get(target[key].targetUrl, Object.assign({}, { params: query }, opt)) } promise .then(data =&gt; resolve(data)) .catch(err =&gt; { fallbackMiddleWare(target[key], err, reject) }); }) } else if (method.toUpperCase() === 'PATCH') { return (body = {}, opt) =&gt; new Promise((resolve, reject) =&gt; { foreRequestMiddleWare(target[key], body); axios.patch(target[key].targetUrl, body, opt) .then(data =&gt; resolve(data)) .catch(err =&gt; { fallbackMiddleWare(target[key], err, reject) }); }) } else if (method.toUpperCase() === 'POST') { return (body = {}, opt) =&gt; new Promise((resolve, reject) =&gt; { foreRequestMiddleWare(target[key], body); axios.post(target[key].targetUrl, body, opt) .then(data =&gt; resolve(data)) .catch(err =&gt; { fallbackMiddleWare(target[key], err, reject) }); }) } else if (method.toUpperCase() === 'DELETE') { return (query = {}, opt) =&gt; new Promise((resolve, reject) =&gt; { foreRequestMiddleWare(target[key], query); let promise = null; if (target[key].resource) { promise = axios.delete(target[key].targetUrl, {}, opt) } else { promise = axios.delete(target[key].targetUrl, Object.assign({}, { params: query }, opt)) } promise .then(data =&gt; resolve(data)) .catch(err =&gt; { fallbackMiddleWare(target[key], err, reject) }); }) } else if (method.toUpperCase() === 'PUT') { return (body = {}, opt) =&gt; new Promise((resolve, reject) =&gt; { foreRequestMiddleWare(target[key], body); axios.put(target[key].targetUrl, body, opt) .then(data =&gt; resolve(data)) .catch(err =&gt; { fallbackMiddleWare(target[key], err, reject) }); }) } else { throw new Error('【API】API源数据信息错误，不支持的方法：' + method); }}const API_ = {};Object.keys(APIS).forEach(apiName =&gt; { API_[apiName] = Proxyable(APIS[apiName]);});export default API_; 当系统有很多功能模块，每个模块都有许多接口时，我们可以按不同的功能模块把api写在不同的src / api / modules / xxx(模块名).api.js文件中，每个 xxx.api.js 文件只写本模块相关的 api。 记得在main.js中引入axios相关文件，这样就不用每个文件引入axios了。 Axios的引用和依赖关系：main.js &lt;== api/index.js &lt;== axios.js main.js123import api from './api';Vue.prototype.$api = api; 现在，我们可以直接通过this.$api.[模块名].[接口名]的形式在任意页面调用接口了。views/movie/top250.vue中的getList方法可以改成这样： top250.vue123456789getList() { this.$api.movie.getTop250({ count: 30 }).then(data =&gt; { this.data = data.subjects }).catch(err =&gt; { // });},","link":"/2020/03/18/blog16/"},{"title":"从零开始搭建后台管理系统（三）Vuex","text":"本项目基于 Vue全家桶 和 Ant Design 进行开发。 目录 安装脚手架工具（vue-cli）、创建新项目 引入 Ant Design 引入 Vue Router 引入 node-sass/sass-loader 登录页 完成页面的基本布局（ 根据路由渲染菜单组件、面包屑组件等 ） 使用 Vuex 完成菜单的显示隐藏 Ajax 以及 Axios 的封装 全局方法 Utils、混合 Mixins 后续功能开发 7.使用Vuex完成菜单的显示隐藏把控制菜单显示隐藏的按钮写在菜单组件中毫无难度，但是我们希望把这个按钮移到头部组件中，对于跨组件的通信，需要使用 Vuex。 趁此机会系统地梳理一下 Vuex 的用法。 安装1$ npm install vuex --save 7.1. state在src目录下新建store/index.js文件： store/index.js12345678910111213import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const store = new Vuex.Store({ state: { collapsed: false, logoShow: true, },})export default store 在main.js中引入并使用store： main.js1234567891011121314151617181920212223242526import Vue from 'vue'import App from './App.vue'import router from './router'import store from './store' // +import { Input, Button, Menu, Icon, Breadcrumb,} from 'ant-design-vue';Vue.use(Input)Vue.use(Button)Vue.use(Menu)Vue.use(Icon)Vue.use(Breadcrumb)Vue.config.productionTip = falsenew Vue({ router, store, // + render: h =&gt; h(App),}).$mount('#app') 在其他页面和组件中能通过this.$store.state或者mapState拿到store.state中定义的值。 7.2. getters在store/index.js中添加getter： store/index.js123456789101112131415161718import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const store = new Vuex.Store({ state: { collapsed: false, logoShow: true, }, getters: { // es6语法,箭头函数更简洁 collapsedText: state =&gt; 'hahaha' + state.collapsed, logoShowText: state =&gt; 'hahaha' + state.logoShow, }})export default store Getter相当于vue中的computed计算属性，在其他页面和组件中可以通过this.$store.getters或者mapGetters拿到值。 xxx.vue1234567891011import { mapState,mapGetters } from \"vuex\";export default { computed: { ...mapState([\"collapsed\",\"logoShow\"]),// 将 `this.collapsed` 映射为 `this.$store.state.collapsed` ...mapGetters([\"collapsedText\",\"collapsedText\"]),// 将 `this.collapsedText` 映射为 `this.$store.getters.collapsedText }, created() { console.log(this.$store.state.collapsed) // 通过$store取值 console.log(this.collapsed,this.logoShow,this.collapsedText,this.collapsedText) // 通过 mapState,mapGetters },} 7.3. mutations在store/index.js中继续添加mutations： store/index.js12345678910const store = new Vuex.Store({ //...... mutations: { changeShowState(state) { state.collapsed = !state.collapsed state.logoShow = !state.logoShow } }, //......}) 在其他页面和组件中可以使用this.$store.commit(‘changeShowState’)或者mapMutations来调用mutation去修改state中的值。 修改aside和header组件的相关代码： aside.vue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;template&gt; &lt;div class=\"myAside\"&gt; &lt;div class=\"logo\" v-if=\"logoShow\"&gt;阿里巴巴后台管理系统&lt;/div&gt; &lt;!-- 菜单组件 --&gt; &lt;a-menu :defaultSelectedKeys=\"selectedKeys\" :inlineCollapsed=\"collapsed\" :openKeys.sync=\"openKeys\" mode=\"inline\" theme=\"dark\" &gt; &lt;template v-for=\"item in routeData\"&gt; &lt;!-- 有children的路由 --&gt; &lt;!-- 省略 --&gt; &lt;!-- 无children的路由 --&gt; &lt;!-- 省略 --&gt; &lt;/template&gt; &lt;/a-menu&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import { mapState } from \"vuex\"; export default { data() { return { routeData: [], selectedKeys: [], openKeys: [], }; }, computed: { ...mapState([\"collapsed\",\"logoShow\"]), }, created() { // 省略 }, methods: { // 省略 } }&lt;/script&gt;&lt;style lang=\"scss\"&gt;&lt;/style&gt; header.vue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;template&gt; &lt;div class=\"myHeader\"&gt; &lt;a-button @click=\"toggleCollapsed\" type=\"primary\" &gt; &lt;a-icon :type=\"collapsed ? 'menu-unfold' : 'menu-fold'\" /&gt; &lt;/a-button&gt; &lt;div class=\"myHeader-right\"&gt; &lt;div&gt;马云&lt;/div&gt; &lt;div style=\"margin:0 16px;color:blue\"&gt;退出登录&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import { mapState, mapGetters, mapMutations } from \"vuex\"; export default { data() { return { }; }, computed: { ...mapState([\"collapsed\"]), }, methods: { ...mapMutations(['changeShowState']),// 将 `this.changeShowState()` 映射为 `this.$store.commit('changeShowState')` toggleCollapsed() { // this.$store.commit('changeShowState') this.changeShowState() }, } }&lt;/script&gt;&lt;style lang=\"scss\"&gt; .myHeader { height: 66px; background-color: #fff; font-size: 14px; box-shadow: 5px 0px 10px #ccc; display: flex; padding: 0 24px; justify-content: space-between; align-items: center; &amp;-right { display: flex; justify-content: space-between; } }&lt;/style&gt; 修改之后，可以点击头部组件的按钮来控制菜单的显示隐藏了： 7.4. actions通过 Action 提交 mutation，再通过 mutation 去改变 state，乍一眼看上去感觉多此一举，我们直接分发mutation岂不更方便？ 实际上并非如此，mutation 必须是同步函数，任何在回调函数中进行的状态的改变都是不可追踪的。在mutation 中混合异步调用会导致程序很难调试，为了处理异步操作，我们需要Action。 store/index.js123456789101112131415161718192021222324const store = new Vuex.Store({ state: { collapsed: false, logoShow: true, }, getters: { // ...... }, mutations: { changeShowState(state) { state.collapsed = !state.collapsed state.logoShow = !state.logoShow } }, actions: { changeShowStateAsync({ commit }) { // 在action中加上1s的延迟表示异步， // 实际开发中是在各种api的回调函数中commit mutation。 setTimeout(() =&gt; { commit('changeShowState') }, 1000); } },}) Action通过this.$store.dispatch方法触发。我们将header组件中按钮的点击事件函数修改为使用Action： header.vue12345toggleCollapsed() { // this.$store.commit('changeShowState') // mutation // this.changeShowState() // mutation this.$store.dispatch('changeShowStateAsync') // action}, 现在点击按钮，效果变成了点击事件触发后1s菜单才隐藏/显示。同样，Actions也可以通过mapActions来简化写法。 header.vue1234567891011121314151617181920212223242526272829import { mapState, mapGetters, mapMutations,mapActions } from \"vuex\";export default { data() { return { }; }, computed: { // 将 `this.collapsed` 映射为 `this.$store.state.collapsed` ...mapState([\"collapsed\"]), // 将 `this.collapsedText` 映射为 `this.$store.getters.collapsedText ...mapGetters([\"collapsedText\"]), }, created() { }, methods: { // 将 `this.changeShowState()` 映射为 `this.$store.commit('changeShowState')` ...mapMutations(['changeShowState']), // 将 `this.changeShowStateAsync()` 映射为 `this.$store.dispatch('changeShowStateAsync')` ...mapActions(['changeShowStateAsync']), toggleCollapsed() { // this.$store.commit('changeShowState') // mutation // this.changeShowState() // mutation 的映射 // this.$store.dispatch('changeShowStateAsync') // action this.changeShowStateAsync() // action 的映射 }, }} 当然，仅就本节的显示隐藏菜单功能没必要使用Action。 其实我尝试在 mutations 中使用异步操作，一样可以正确执行，也就是说异步 Mutation 不会对数据造成丢失或其他影响。 vuex原文解释：『在 mutation 中混合异步调用会导致你的程序很难调试。例如，当你能调用了两个包含异步回调的 mutation 来改变状态，你怎么知道什么时候回调和哪个先回调呢？这就是为什么我们要区分这两个概念。在 Vuex 中，mutation 都是同步事务。』 我们使用Devtools去看state的变化，当我们去查看多次Mutation状态时，发现同步的显示Ok，异步Mutation的 state 数据显示和我们预期结果不一致，所以会造成状态改变的不可追踪，所以官方说我们Mutation是同步的。 mutation的提交是对state做确定的 、立即生效的修改。","link":"/2020/03/17/blog15/"},{"title":"盘点一些常用的语法和知识点-JavaScript篇","text":"（持续更新中……）本文盘点了一些工作中会经常使用到的，或者是比较重要但是不太熟练的语法和知识点。 数组常用的一些方法传送门（js数组常用方法） 字符串去空格 trim()123456let str1 = \" aaa \"str1.trim()console.log(str1) //trim()不会改变原字符串，打印结果str1为\" aaa \"let str2 = str1.trim()console.log(str2) //trim()会返回一个新的字符串，打印结果str2为\"aaa\" 遍历js对象 12345678910111213141516171819let obj = { name: 'Boa Hancock', age: 31, gender: 'female'}// 方法一for(var name in obj) { console.log(name,\":\",obj[name]);}// 方法二Object.keys(obj).forEach(function(key){ console.log(key,\":\",obj[key]);});/*打印结果：name : Boa Hancockage : 31gender : female*/ 深拷贝var deepCloneObj = JSON.parse(JSON.stringify(obj)) 截取字符串或数组slice(起始位置index1,结束位置index2)需要注意的是，截取的结果包括index1对应的项，不包括index2对应的项12345let str = 'sesshouin kiara'console.log(str.slice(0,5)) //输出\"sessh\"let arr = [1,2,3,4,5,6,7]console.log(arr.slice(0,5)) //输出[1,2,3,4,5]","link":"/2019/12/26/blog2/"},{"title":"从零开始搭建后台管理系统（五）Utils、Mixins","text":"本项目基于 Vue全家桶 和 Ant Design 进行开发。 目录 安装脚手架工具（vue-cli）、创建新项目 引入 Ant Design 引入 Vue Router 引入 node-sass/sass-loader 登录页 完成页面的基本布局（ 根据路由渲染菜单组件、面包屑组件等 ） 使用 Vuex 完成菜单的显示隐藏 Ajax 以及 Axios 的封装 全局方法 Utils、混合 Mixins 后续功能开发 9. 全局方法 Utils、混合 Mixins9.1. Utils项目中有一些方法很多地方都会用到，我们可以创建一个utils.js文件存放这些方法： src/utils.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214const STORAGE_ENGINE = localStorage;// const STORAGE_ENGINE = sessionStorage;const Utils = { // 在stroage中存/取数据 setItem(key, val) { if (typeof val === 'object') { STORAGE_ENGINE.setItem(key, JSON.stringify(val)) } else { STORAGE_ENGINE.setItem(key, val) } }, getItem(key) { let ele = STORAGE_ENGINE.getItem(key); let val = null; try { val = JSON.parse(ele); } catch (error) { val = ele; } return val; }, // 用户信息相关方法 // 在stroage中存/取用户token setToken(token) { STORAGE_ENGINE.setItem('_token', token); }, getToken() { return STORAGE_ENGINE.getItem('_token'); }, // 在stroage中存/取用户信息 setUserInfo(userInfo) { STORAGE_ENGINE.setItem('_userInfo', userInfo); }, getUserInfo() { return STORAGE_ENGINE.getItem('_userInfo'); }, // 清除stroage中数据 clear() { STORAGE_ENGINE.clear(); }, //登出 logout() { this.clear(); }, // 获取登录时存放的权限字段数组 getPermission() { let val = []; try { val = JSON.parse(STORAGE_ENGINE.getItem('_permission_')); } catch (error) { val = []; } return val; }, // 权限控制：根据权限字段返回Boolean值，用来判断路由或者页面中按钮的显示隐藏 canVisit(name) { let permission = this.getPermission(); if (!Array.isArray(permission)) { permission = []; } let isPermission = false let obj = null; obj = permission.find((item, index) =&gt; { return item.symbol.includes(name); }); if (obj) { isPermission = true; }; if (isPermission || name === 'index' || name === 'homeIndex') { return true; } else { return false; } // return true; }, /** * 对象的深度拷贝 * @param data 需要拷贝的元数据 * @return {any} 返回拷贝后的新数据 */ deepClone(data) { const type = this.getType(data); let obj; if (type === 'array') { obj = []; } else if (type === 'object') { obj = {}; } else { //不再具有下一层次 return data; } if (type === 'array') { for (let i = 0, len = data.length; i &lt; len; i++) { obj.push(this.deepClone(data[i])); } } else if (type === 'object') { for (let key in data) { obj[key] = this.deepClone(data[key]); } } const constructor = data.constructor; if (constructor) { return Object.assign(new constructor(), obj); } return obj; }, numFormat(num) { var c = (num.toString().indexOf('.') !== -1) ? num.toLocaleString() : num.toString().replace(/(\\d)(?=(?:\\d{3})+$)/g, '$1,'); return c; }, /** * 处理空的参数 * @param data * @returns */ cleanData(data) { let _data = {}; for (let key in data) { if (Object.prototype.toString.call(data[key]) === '[object Object]') { _data[key] = null; } else if (data[key] instanceof Array) { _data[key] = []; } else { _data[key] = undefined; } } return _data; }, /** * 判断对象类型 * @param {Object} object * @return {String} object type */ getType(object) { var toString = Object.prototype.toString; var map = { '[object Boolean]': 'boolean', '[object Number]': 'number', '[object String]': 'string', '[object Function]': 'function', '[object Array]': 'array', '[object Date]': 'date', '[object RegExp]': 'regExp', '[object Undefined]': 'undefined', '[object Null]': 'null', '[object Object]': 'object' }; if (object instanceof Element) { return 'element'; } return map[toString.call(object)]; }, preventClose(e) { e = e || window.event; // 兼容IE8和Firefox 4之前的版本 if (e) { e.returnValue = '关闭提示'; } // Chrome, Safari, Firefox 4+, Opera 12+ , IE 9+ return '关闭提示'; }, /** * * @param {路由守卫next回调} next * @param {vue} that */ showConfirm(next, that) { that.$confirm({ title: '确定要离开当前页面吗？', content: '离开后您将取消本次编辑的全部内容，确定要离开吗？', cancelText: \"取消\", okText: '确定', centered: true, onOk() { next(); }, onCancel() { that.$router.go(1); }, class: 'test', }); }, //附件url转换 changefileUrl(url, str = '') { let arr = url ? url.split(',') : []; let arr1 = []; arr.map((ele, index) =&gt; { let one = ele.lastIndexOf('_'); let two = ele.lastIndexOf('.'); let newStr = ele.replace(ele.substring(one, two), ''); let arr = newStr.split('/') let name = arr[arr.length - 1]; arr1.push({ uid: (index + 1) / -1 + '', name: name, url: ele, status: 'done' }) }) return arr1; },};export default Utils; 用的时候引入就可以了 1import Utils from \"@/utils\"; 9.2. Mixins像这类的后台管理系统，基本上每个模块都会有很多的列表页、表格页，会大量的使用到antd的table组件，我们完全可以把与之相关的一些属性和方法写到mixins.js里。 src/mixins.js123456789101112131415161718192021222324252627282930313233343536export default { data() { return { searchObj: {},//搜索条件的对象 pagination: { current: 1, pageSize: 10, total: 0, showTotal() { return `共 ${this.total} 条数据` }, showSizeChanger: true }, } }, methods: { // 搜索方法 query() { this.$set(this.pagination, 'current', 1); this.$set(this.pagination, 'pageSize', 10); this.getList(); }, // 重置搜索字段方法 reset() { this.$set(this.pagination, 'current', 1); this.$set(this.pagination, 'pageSize', 10); this.$refs.dp.reset(); this.getList(); }, paginationChange(pagination, sorter) { this.pagination.current = pagination.current; this.pagination.pageSize = pagination.pageSize; this.getList(); } }} 使用的时候在页面注入就行了： 1234567891011&lt;script&gt; import mixins from \"@/plugins/mixins\"; export default { mixins: [mixins], data() { return { // } } }&lt;script&gt; 10. 后续功能开发经过前面的9个步骤，我们已经完成了下列工作： 创建了项目，并且引入了 Ant Design、node-sass/sass-loader、Vue Router、Vuex、Axios 等插件。 完成了路由的搭建和页面的布局，包括一些组件的创建（登录页、菜单、面包屑、头部组件等） 封装了Axios和一些全局方法。 项目的基本框架和方法封装已经完成，接下来功能模块的开发都是一些业务逻辑代码，只需要根据已有的模板，按照模块化、组件化的思想继续开发就行了。 （完）","link":"/2020/03/19/blog17/"},{"title":"对Js闭包的理解","text":"讨论js闭包的文章，网络上多不胜数。但是要加深理解，还是要亲自撸一遍。 1. 如何产生闭包？（产生闭包的条件）函数嵌套时，内部(子)函数引用了外部(父)函数的变量(函数)，并且调用了外部(父)函数，此时就会产生闭包。 闭包的一个例子12345678910111213141516171819&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Page Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; function fn1() { let name = \"Jack\" let age = 28 function fn2() { console.log('my name is ' + name) } fn2() } fn1()//调用fn1 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2. 闭包是什么？ 对于闭包是什么，很多种理解： 嵌套的内部函数 包含被引用的变量的对象（存在于内部函数中） 内部函数以及它能访问到的变量 对于这些闭包是什么的解释，可能并不是能直观，也不方便初学者的理解。所以我们通过Chrome的开发者工具来看看。 还是上面那段代码，在fn2()那一行打上断点，调试查看。此时的上下文变量如图： fn1函数的内部环境中，有name、age、fn23个变量。 点开fn2，可以发现其中有个Closure（闭包）对象： 需要注意到的是，Closure对象内部只有name属性，并没有age，这是因为fn2中并没有引用age属性。 通过开发者工具，就能比较直观的理解闭包的3种说法了。 我们可以把闭包理解成内部函数fn2本身，也可以理解成fn2中的Closure对象：{name: “Jack”}，或者说是fn2以及它能访问到的属性（name），即内部函数所处的环境。 3.闭包的特点及作用 闭包有如下特点： 可以读取函数内部的变量。 可以让这些局部变量始终保持在内存中，不会因外部函数调用完毕而被销毁（也就是说，闭包可以使它的诞生环境一直存在）。 因为这两个特点，闭包可以用来封装私有变量。 4. 闭包在实际开发中的运用上述闭包在实际开发中是没有什么实际意义的，而实际开发中，一般会将内部函数作为外部函数的返回值。 注意：闭包的产生与是否返回内部函数无关。 我们来看一个例子： 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div&gt; &lt;div&gt;Closure Test&lt;/div&gt; &lt;a-button @click=\"addStar(2)\"&gt;升2星&lt;/a-button&gt; &lt;!-- 2的作用是star每次加2 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { data() { return { addStar: {} // 函数也是对象 }; }, created() { // this.addStar 现在是一个闭包,8的作用是初始化star this.addStar = this.starRepo(8); }, methods: { //x:基础星级；y:上升梯度 starRepo(x) { var star = x; return function (y) { star = star + y console.log(\"星级star:\",star) } }, } }&lt;/script&gt; 在18行，this.starRepo(8)执行会返回一个内部函数（闭包），并将这个内部函数赋给this.addStar。 这里产生了一个闭包，之后每次点击“升2星”按钮时，会执行这个已经产生的内部函数（闭包），但不会产生新的闭包。即无论点击多少次按钮，上述代码都只会在created生命周期中调用外部函数starRepo的时候产生一个闭包。 虽然addStar是在starRepo函数外部调用的，但由于闭包的特性，使得addStar还是能访问starRepo函数内部属性star。 连续点击5次按钮，输出如下： 函数本来在执行之后会立即销毁，但由于生成了闭包，starRepo中的star始终保存在内存之中，并没有销毁，而是随着每次事件的触发而累加。 4.结尾其实上面阐述的对闭包的3种理解，更多的只是为了说出一个知识点，而不是一定要给闭包找到一个绝对正确的定义。 很多时候，一种工具或概念被发明出来，其目的是为了更方便的开发。所以当你觉得某个概念复杂而难以使用时，那很可能是走入了误区。 看过这样一段话，觉得很有道理： 编程界崇尚以简洁优雅为美，很多时候 如果你觉得一个概念很复杂，那么很可能是你理解错了。 相关链接： JS 中的闭包是什么？（来源：知乎） Javascript闭包——懂不懂由你，反正我是懂了（来源：博客园）","link":"/2020/03/20/blog18/"},{"title":"使用vuedraggable进行拖拽操作","text":"公司新项目需要实现拖拽排序的功能，包括 列表拖拽、表格拖拽、卡片拖拽 等等。这些不同的拖拽需求其原理是一样的，只不过是样式的区别而已。 我使用了vuedraggable这个插件，这里记录一下基本的使用方法。 安装1npm install vuedraggable 直接上代码： html1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;content-view class=\"home-page\"&gt; &lt;div class=\"bg-white pt24 pr32 pl32 pb32 content\"&gt; &lt;!-- 添加拖拽功能时，只需要添加一个 draggable 标签就行了 --&gt; &lt;draggable v-model=\"listData\" @start=\"drag=true\" @end=\"drag=false\" @change=\"change\" &gt; &lt;!-- 遍历数据，渲染卡片 --&gt; &lt;div class=\"card\" v-for=\"(item,index) in listData\" :key=\"index\" &gt; &lt;div class=\"left\"&gt; &lt;div class=\"avatar\" :style=\"`background-image:url(${item.avatar})`\" &gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"right\"&gt; &lt;div class=\"name\"&gt;姓名：{{item.name}}&lt;/div&gt; &lt;div class=\"age\"&gt;年龄：{{item.age}}&lt;/div&gt; &lt;div class=\"age\"&gt;地址：{{item.address}}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/draggable&gt; &lt;/div&gt; &lt;/content-view&gt;&lt;/template&gt; js123456789101112131415161718192021222324252627282930313233343536&lt;script&gt;import draggable from \"vuedraggable\"; // 引入vuedraggableexport default { data() { return { listData: [] }; }, components: { draggable // 注册vuedraggable组件 }, created() { this.getList(); }, methods: { getList() { this.listData = []; for (let i = 1; i &lt; 6; i++) { this.listData.push({ id: i, name: `王${i}`, age: 20 + i, address: `海军本部G${i}`, avatar: \"https://wh-1301033226.cos.ap-nanjing.myqcloud.com/Hexo_img/wzxAvatar.jpg\" }); } }, // 拖拽时的触发事件 change({moved}) { console.log('当前拖动的卡片：',moved); console.log('整个卡片数组：',this.listData) } }};&lt;/script&gt; css其实没必要放上来，但是卡片头像那一块用到了背景图片自动填充且居中显示的属性，就顺便贴一下。 css12345678910111213141516171819202122232425262728293031323334&lt;style lang=\"scss\"&gt;.content { .card { width: 420px; height: 230px; margin-bottom: 32px; border-radius: 6px; display: flex; padding: 16px; background-color: rgba($color: #000000, $alpha: 0.05); .left { height: 100%; width: 40%; .avatar { height: 100%; border-radius: 6px; /* 背景图片填充且居中 */ background-repeat: no-repeat; background-size: cover; background-position: center; } } .right { flex: 1; height: 100%; display: flex; flex-direction: column; font-size: 18px; justify-content: space-around; padding-left: 24px; } }}&lt;/style&gt; 效果图： 在被拖拽组件的外层套一个draggable标签，并将渲染卡片的数据listData绑定到draggable标签的v-model中，就可以使用拖拽功能了。 每次拖拽时，都会触发change事件。一般业务逻辑的代码都会写在change事件中，而这里面我们一般会用到两个数据：listData和moved。 listData是渲染的数据源，和draggable的v-model是双向绑定的。拖拽发生后，listData会自动改变。 moved是change()默认参数的一个属性，将其打印出来，发现这是一个由被拖拽的对象、拖拽之前的索引、拖拽之后的索引所组成的对象。","link":"/2020/04/18/blog20/"},{"title":"常用es6/7语法汇总","text":"本文整理了一些常用的es6、es7语法。 1. let和const es5没有块级作用域的概念，es6新增了块级作用域的概念。let和const只能在块级作用域里访问，不能跨块访问。 其中，let定义变量，const定义常量（使用时必须初始化，即必须赋值，且不能修改）。 2. 模板字符串（``） 以下a和b是一样的：123const name = 'Boa'var a = 'my name is '+ namevar b = `my name is ${name}` 3. 解构赋值 数组12var [a,b] = [11,22]console.log(a,b) //11 22 对象（不完全解构）12var {name,age} = {name:'tom',age:22,id:'430181xxxxxxxx'} //不完全解构console.log(name,age) //tom 22 4. 扩展运算符（…）其功能是将一个数组转为用逗号分隔的参数序列。 12console.log(...[1, 2]) // 1 2 console.log(1, ...[2, 3, 4], 5) // 1 2 3 4 5 5. 箭头函数 注：箭头函数this永远指向其父作用域 12345678910// 基本形式如下：var func = (a,b) =&gt; { return a+b}// 当参数只有一个时，可省略参数的括号:var func = a =&gt; { return a+1}// 箭头后直接接表达式（省略大括号和return），代表直接返回箭头后面的表达式:var func = a =&gt; a+1 6. 对象简洁写法 123456let name = 'Boa'let obj = { // name: name //es5写法，必须写完整的key-value键值对 name, //es6写法，当键值对前后相等时，可缩写。 age:32} 7. Promise Promise的含义： Promise 的英文本意是承诺。古人云：“君子一诺千金”，这种“承诺将来会执行”的对象在 JavaScript 中称为 Promise 对象。 它是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果，并且这个事件提供统一的 API ，可供进一步处理。 Promise出现之前，代码往往会有过多的回调或者嵌套，导致可读性差、耦合度高、扩展性低，甚至出现回调地狱。 Promise就是用同步编程的方式来编写异步代码，保存线性的代码逻辑，极大的降低了代码耦合性而提高了程序的可扩展性。 Promise机制的出现，扁平化了代码的结构，大大提高了代码可读性； 一个promise对象12345678910new Promise( function (resolve, reject) { // 一段耗时的异步操作 resolve('成功') // 数据处理完成 // reject('失败') // 数据处理出错 }).then( (res) =&gt; {console.log(res)}, // 成功 (err) =&gt; {console.log(err)} // 失败) promise对象有三个状态： pending初始状态，表示【进行中】； fulfilled【已成功】； rejected【已失败】 resolve 作用是，将Promise对象的状态从【进行中】变为【已成功】（即从 pending 变为 fulfilled），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject 作用是，将Promise对象的状态从【进行中】变为【已失败】（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 当promise状态发生改变，就会触发then()里的响应函数处理后续步骤； Promise对象的状态改变，只有两种可能： 从 pending 变为 fulfilled 从 pending 变为 rejected 这两种情况只要发生，状态就凝固了。也就是说，promise状态一经改变，就不会再变。 相关文档：阮一峰ES6之promise 8. async/await async函数是Generator函数的语法糖。 我们先来看看async函数是怎么处理他的返回值的： 12345async function testAsync() { return \"hello async\";}const result = testAsync();console.log(result); 输出结果如图： 注：有时候认为resolved和fulfilled是等价的表述，甚至用resolved表示fulfilled。 得出结论：async函数返回的是一个Promise对象。 如果在 async 函数中 return 一个直接量，async 会把这个直接量通过Promise.resolve()封装成Promise对象。 再来看一个实际运用async/await例子： html12345&lt;template&gt; &lt;div class=\"navMain\"&gt; &lt;button @click=\"print\"&gt;打印&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; js1234567891011121314151617181920212223242526272829303132&lt;script&gt;export default { data() { return { state: \"幼虫\" }; }, methods: { grow() { return new Promise((resolve, reject) =&gt; { // 模拟一段耗时的异步操作 setTimeout(() =&gt; { let resData = \"成虫\"; resolve(resData); // 状态从pending变为fulfilled，并将resData作为参数传到then中 }, 1000); }).then( res =&gt; { console.log(res); this.state = res }, // 成功 err =&gt; { console.log(err); } // 失败 ); }, async print() { await this.grow(); console.log(\"现在的状态是：\", this.state); }, }};&lt;/script&gt; 点击按钮，控制台输出字符串：”现在的状态是：成虫”。 分析：grow函数： grow函数包含一个耗时的异步操作，可以理解为实际开发中的向后台请求接口数据。该函数返回一个promise对象，通过then添加回调函数。 可以看到，这个promise对象一直在等待异步操作（定时器）执行，定时器触发之后通过resolve将promise对象的状态从pending变为fulfilled，从而触发then中的成功回调，并将resData作为参数传到then中。 按照我们的需求，print函数是依赖grow函数执行结果的，也就是说需要等grow执行完毕后再执行自己的代码。 所以我们使用async/await： 当 async 函数（即 print 函数）执行的时候，一旦遇到了 await ，并且 await 的是一个 Promise 对象，就会阻塞后面的代码，等待这个 Promise 对象 resolve 。异步操作完成后，再接着执行函数体内后面的语句。 相关文档：理解 JavaScript 的 async/await","link":"/2020/06/17/blog23/"},{"title":"使用Echarts绘制geo航线图","text":"前不久接到一个任务，是绘制一个物流公司的运输路线图。记录一下完成这个功能的过程。 产品要求如下： 不多说，直接上代码。在地图中绘制散点图和线图需要各城市的经纬度坐标，这里直接给出： 散点图Data12345678910111213141516171819202122232425262728293031323334353637383940414243444546let pointData = [{ name: '上海', value: [121.77333, 31.03000]}, { name: '北京', value: [116.41667, 39.91667]}, { name: '广州', value: [113.23333, 23.16667]}, { name: '杭州', value: [120.20000, 30.26667]}, { name: '南京', value: [118.78333, 32.05000]}, { name: '重庆', value: [106.45000, 29.56667]}, { name: '长沙', value: [113.00000, 28.21667]}, { name: '厦门', value: [118.10000, 24.46667]}, { name: '成都', value: [104.06667, 30.66667]}, { name: '拉萨', value: [91.00000, 29.60000]}, { name: '乌鲁木齐', value: [87.68333, 43.76667]}, , { name: '昆明', value: [102.73333, 25.05000]}, { name: '西安', value: [108.95000, 34.26667]}, { name: '哈尔滨', value: [126.63333, 45.75000]}, { name: '武汉', value: [114.31667, 30.51667]}] 线图Data123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111let lineData1 = [{ fromName: '上海', toName: '北京', coords: [[121.77333, 31.03000], [116.41667, 39.91667]]}, { fromName: '上海', toName: '广州', coords: [[121.77333, 31.03000], [113.23333, 23.16667]]}, { fromName: '上海', toName: '杭州', coords: [[121.77333, 31.03000], [120.20000, 30.26667]]}, { fromName: '上海', toName: '南京', coords: [[121.77333, 31.03000], [118.78333, 32.05000]]}, { fromName: '上海', toName: '重庆', coords: [[121.77333, 31.03000], [106.45000, 29.56667]]}, { fromName: '上海', toName: '长沙', coords: [[121.77333, 31.03000], [113.00000, 28.21667]]}, { fromName: '上海', toName: '厦门', coords: [[121.77333, 31.03000], [118.10000, 24.46667]]}, { fromName: '上海', toName: '成都', coords: [[121.77333, 31.03000], [104.06667, 30.66667]]}, { fromName: '上海', toName: '拉萨', coords: [[121.77333, 31.03000], [91.00000, 29.60000]]}, { fromName: '上海', toName: '乌鲁木齐', coords: [[121.77333, 31.03000], [87.68333, 43.76667]]}, { fromName: '上海', toName: '昆明', coords: [[121.77333, 31.03000], [102.73333, 25.05000]]}, { fromName: '上海', toName: '西安', coords: [[121.77333, 31.03000], [108.95000, 34.26667]]}, { fromName: '上海', toName: '哈尔滨', coords: [[121.77333, 31.03000], [126.63333, 45.75000]]}, { fromName: '上海', toName: '武汉', coords: [[121.77333, 31.03000], [114.31667, 30.51667]]}]let lineData2 = [{ fromName: '广州', toName: '杭州', coords: [[113.23333, 23.16667], [120.20000, 30.26667]]}, { fromName: '广州', toName: '南京', coords: [[113.23333, 23.16667], [118.78333, 32.05000]]}, { fromName: '广州', toName: '重庆', coords: [[113.23333, 23.16667], [106.45000, 29.56667]]}, { fromName: '广州', toName: '长沙', coords: [[113.23333, 23.16667], [113.00000, 28.21667]]}, { fromName: '广州', toName: '厦门', coords: [[113.23333, 23.16667], [118.10000, 24.46667]]}, { fromName: '广州', toName: '成都', coords: [[113.23333, 23.16667], [104.06667, 30.66667]]}, { fromName: '广州', toName: '拉萨', coords: [[113.23333, 23.16667], [91.00000, 29.60000]]}, { fromName: '广州', toName: '乌鲁木齐', coords: [[113.23333, 23.16667], [87.68333, 43.76667]]}, { fromName: '广州', toName: '昆明', coords: [[113.23333, 23.16667], [102.73333, 25.05000]]}, { fromName: '广州', toName: '西安', coords: [[113.23333, 23.16667], [108.95000, 34.26667]]}, { fromName: '广州', toName: '哈尔滨', coords: [[113.23333, 23.16667], [126.63333, 45.75000]]}, { fromName: '广州', toName: '武汉', coords: [[113.23333, 23.16667], [114.31667, 30.51667]]}, { fromName: '广州', toName: '北京', coords: [[113.23333, 23.16667], [116.41667, 39.91667]]}] 实际开发中，不同的场景可能需要通过不同的方式获取地点坐标，例如调用地图api、从项目服务端获取、直接下载资源js文件等，但最终用来渲染的数据都应该是上面的格式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175&lt;script&gt; import echarts from 'echarts' import '../../../node_modules/echarts/map/js/china.js' // 引入中国地图 // import '../../../node_modules/echarts/map/js/world.js' // 引入世界地图 export default { data() { return { } }, created() { }, mounted() { this.drawMap() }, methods: { drawMap() { // 定义飞机飞行路线的运行效果 let planePath = 'path://M1705.06,1318.313v-89.254l-319.9-221.799l0.073-208.063c0.521-84.662-26.629-121.796-63.961-121.491c-37.332-0.305-64.482,36.829-63.961,121.491l0.073,208.063l-319.9,221.799v89.254l330.343-157.288l12.238,241.308l-134.449,92.931l0.531,42.034l175.125-42.917l175.125,42.917l0.531-42.034l-134.449-92.931l12.238-241.308L1705.06,1318.313z'; // 定义路线hover时的显示 let label = { normal: { show: false, // formatter: '{b}', //标签内容格式器。模板变量有 {a}、{b}、{c}，分别表示系列名，数据名，数据值。 formatter: function (params) { // console.log(params) // params中包含这个canvas图标中的所有数据 return '路线' + '：' + params.data.fromName + '-' + params.data.toName }, textStyle: { fontSize: 12, backgroundColor: '#999', color: 'white', lineHeight: 24, padding: [2, 10, 0, 10], borderRadius: 6, } }, emphasis: { show: true, } } let option = { title: { text: '物流运输全国路线覆盖', textStyle: { fontStyle: 'normal', fontWeight: '600', fontSize: 16, align: 'center' }, x: 'center', }, legend: { data: ['上海', '广州'], left: 'center', bottom: 0 }, geo: { center: [121.4648, 31.2891], name: '全国', map: 'china', // roam: true, zoom: 1.2, center: [105.97, 35.71], // 省份面积块的样式 itemStyle: { normal: { borderColor: 'white', borderWidth: 1, areaColor: '#c6d9f1' }, emphasis: { areaColor: '#4089d3' } }, // 省份鼠标移入文字的样式 label: { normal: { textStyle: { fontSize: 12, } }, emphasis: { textStyle: { fontSize: 12, color: 'white' } }, }, }, series: [ { name: '上海', type: 'lines', // 飞机飞行路线的运行效果 zlevel: 2, symbolSize: 110, effect: { // 模拟效果路线特效 show: true, period: 6, trailLength: 0, symbol: planePath, symbolSize: 15, }, lineStyle: { normal: { color: '#3f73a8', width: 1, opacity: 0.6, curveness: 0.2 }, emphasis: { width: 2, color: 'red' } }, // label: label, // 将上面let的label注入 data: lineData1 }, { name: '广州', type: 'lines', // 飞机飞行路线的运行效果 zlevel: 2, symbolSize: 110, effect: { show: true, period: 6, trailLength: 0, symbol: planePath, symbolSize: 15, }, lineStyle: { normal: { color: '#9370DB', width: 1, opacity: 0.6, curveness: 0.2 }, emphasis: { width: 2, color: 'red' } }, // label: label, data: lineData2 }, { name: '地点', type: 'effectScatter', // 行程目标地点的 标注 coordinateSystem: 'geo', // 使用的坐标系 zlevel: 3, rippleEffect: { // 涟漪特效相关配置 brushType: 'stoke' }, label: { normal: { show: true, position: 'right', formatter: '{b}' } }, symbolSize: 5, itemStyle: { normal: { color: '#3f73a8' } }, data: pointData } ] } var chart = echarts.init(document.getElementById('map')); chart.setOption(option) }, }, }&lt;/script&gt; 绘制完成，预览效果如图： 有几点需要注意一下： 绘制地图的函数 drawMap需要放在 mounted 中，而不是 created。写在created中会报 “Cannot read property ‘getAttribute’ of null” 的错误。想知道原因，首先需要知道这两个生命周期的区别： created是在模板渲染成 html 前调用，此时 el 还是 undefined ， data 已经存在，此时不能对 dom 进行操作； mounted是在模板渲染成 html 后调用，此时 el ， data 都已经加载完成。一般对 dom 的操作都写在 mounted 中，例如获取 innerHTML ，初始化 echarts 等。 需要绘制的内容可以写在两个地方： 1.放在option的series中（ type 为 line、pie、title、map 等等）， 2.和series同级，以type为对象的名字（例如上面的 title、legend、geo 等）。 样式可以分为normal和emphasis，前者为普通情况下的样式，后者是 hover 时的样式。 两个 linedata 是因为要区分从不同的城市发出的路线以及显示不同的颜色，即鼠标移入不同的legend时，对应的路线应该亮起。要实现这个效果，legend 中的 data 数组项必须是 series 数组中存在的项的 name 字段。某个 legend 处于 hover 状态时，对应的 series 也会处于 hover 状态（鼠标移入上海 legend 时，所有上海的路线都会 hover ）。 最后附上柱状-折现图的绘制方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576drawBar() { let option = { title: { text: '租赁情况', // subtext: '根据档口租赁情况给出', textStyle: { fontStyle: 'normal', fontWeight: '600', fontSize: 16, } }, legend: { data: ['租赁金额', '增长率'], left: 'center', bottom: 0 }, tooltip: { trigger: 'axis', axisPointer: { type: 'cross', crossStyle: { color: '#999' } } }, xAxis: [ { type: 'category', data: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'], axisPointer: { type: 'shadow' } } ], yAxis: [ { type: 'value', name: '租赁金额（元）', min: 0, max: 300, interval: 50, axisLabel: { formatter: '{value} 元' } }, { type: 'value', name: '百分比（%）', min: 0, max: 30, interval: 5, axisLabel: { formatter: '{value} %' } } ], series: [ { name: '租赁金额', type: 'bar', width: '3', color: '#8EE5EE', data: [46, 55.9, 69.0, 36.4, 28.7, 70.7, 175.6, 182.2, 48.7, 78.8, 46.0, 69.3] }, { name: '增长率', type: 'line', color: '#A4D3EE', yAxisIndex: 1, data: [12.0, 12.2, 13.3, 14.5, 16.3, 20.2, 24.3, 27, 21.0, 24.5, 22.0, 16.2] } ] } var chart = echarts.init(document.getElementById('bar')); chart.setOption(option)}","link":"/2020/03/27/blog19/"},{"title":"前端面试题汇总","text":"本文整理了一些前端面试经常会涉及到的知识点。 1.语义化标签 例如&lt;title&gt;&lt;header&gt;&lt;footer&gt;&lt;strong&gt;&lt;article&gt;等。 作用：提高代码的可读性和开发效率，以及让网络爬虫更好的解析。 2.移动端适配 1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt; 3.盒模型 盒模型分为两种：标准盒模型和怪异盒模型，使用box-sizing来定义： 12box-sizing: content-box; //标准盒模型box-sizing: border-box; //怪异盒模型 标准盒模型的width / height指的是content的宽度/高度： 怪异盒模型的width / height指的是content + padding + border的宽度/高度： 4.元素水平和垂直居中 （1）让元素内的文本或图片水平居中，使用:text-align: center; （2）让元素内的文本垂直居中，让其line-height 和 height 相等 （3）让父元素内的子元素水平垂直居中，采用绝对定位、外边距auto的方法： 父元素1234.boxWrap { /* 添加以下属性 */ position: relative;} 子元素123456789.box { /* 添加以下属性 */ position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto;} 该方法的局限性是必须知道div的确定宽高。 （4）让父元素内的子元素水平垂直居中，使用flex，这个算是最普适的方法： 给父元素添加以下css属性：12345.boxWrap { display: flex; justify-content: center; align-items: center;} 5.localstorage、sessionStorage和cookie的比较 大小sessionStorage：5M或者更大localStorage：5M或者更大cookie：一般不超过4K 数据有效期sessionStorage：仅在当前浏览器窗口关闭之前有效，关闭页面或者浏览器会被清除localStorage：永久有效，窗口或者浏览器关闭也会一直保存，除非手动永久清除，因此用作持久数据cookie：一般由服务器生成，可以设置失效时间；若没有设置时间，关闭浏览器cookie失效，若设置了时间，cookie就会存放在硬盘里，过期才失效 作用域sessionStorage：不可以在不同的浏览器中访问、不可以在不同的tab页中访问、必须同源localStorage：不可以在不同的浏览器中访问、可以在不同的tab页中访问、必须同源cookie：不可以在不同的浏览器中访问、可以在不同的tab页中访问、必须同源 6.position各种定位的区别 （1）static：默认值。没有定位，元素出现在正常的流中 （2）relative：相对定位，相对于原位置进行定位，不脱离文档流。 （3）absolute：绝对定位，相对于最近一级的定位不是 static 的父元素来进行定位，脱离文档流。 （4）fixed: 固定定位的元素，相对于浏览器窗口或 frame进行定位，脱离文档流。 7.css选择器及其权重 这里列出所有样式的权重，不仅仅是选择器： （1）! important，权重最高 （2）内联样式，权重1000 （3）id选择器，权重100 （4）类、伪类、属性选择器，权重10 （5）元素、伪元素选择器，权重1 （6）选择器组合，权重会相加，但不能越级 （7）继承的样式，没有权重 8.网络状态码 HTTP状态码分类： （1）1**：信息，服务器收到请求，需要请求者继续执行操作 （2）2**：成功，操作被成功接收并处理 （3）3**：重定向，需要进一步的操作以完成请求 （4）4**：客户端错误，请求包含语法错误或者无法完成请求 （5）5**：服务器错误，服务器在处理请求的过程中发生了错误 常见的HTTP状态码： 200 —— OK，请求成功 301 —— Moved Permanently，资源（网页等）被永久转移到其他URL 302 —— Found，307——Temporary Redirect，临时重定向，请求的文档被临时移动到别处 304 —— Not Modified，未修改，表示客户端缓存的版本是最近的 401 —— Unauthorized，请求要求用户的身份认证 403 —— Forbidden，禁止，服务器理解客户端请求，但是拒绝处理此请求，通常是权限设置所致 404 —— Not Found，请求的资源（网页等）不存在 500 —— Internal Server Error——内部服务器错误 502 —— Bad Gateway，充当网关或代理的服务器从远端服务器接收到了一个无效的请求 504 —— Gateway Time-out，充当网关或代理的服务器，未及时从远端服务器获取请求 9.一次完整的HTTP事务流程有哪些步骤？ （1）域名解析 （2）发起TCP的三次握手 （3）建立TCP连接后发起http请求 （4）服务器响应http请求，浏览器得到HTML代码 （5）浏览器解析HTML代码，并请求HTML代码中的资源 （6）浏览器对页面进行渲染呈现给用户 （7）连接结束 10.性能优化方案 （1）减少 HTTP请求数 （2）资源合并与压缩（js、css等，减少资源的大小） （3）Css Sprite(雪碧图、精灵图)&lt;图像拼合技术&gt; （4）使用字体图标来代替图片 （5）优化资源加载：CSS文件放在head中，JS文件放在body底部，先外链，后本页 （6）优化网络连接，使用CDN加速 （7）模块按需加载 （8）使用缓存 其他之前做过的知识点汇总： js篇 html/css篇 es6/7篇 vue-router篇 vuex ajax 闭包","link":"/2020/06/19/blog24/"},{"title":"H5分享页面-展开全文、收起全文操作","text":"在浏览器中打开从移动端应用分享出来的链接时，页面一般会有一些提示下载APP的浮块和展开全文、收起全文的操作。 例如初始状态的页面是无法上下滑动查看剩余内容的： 点击展开全文后，页面就可以滑动查看下文了： 点击收起全文，页面恢复到不可滑动状态。 实现思路如下： 当处于收起全文状态时（className为showSome）: 页面高度为100vh，多余内容隐藏。 显示展开全文按钮。 页面处于展示全文状态时（className为showAll）: 页面高度为auto（内容多高页面就多高）。 显示收起全文按钮。 几个注意点： 收起全文状态时，整个页面高度为100vh（100vh代表屏幕可见区域的100%），由于下载浮块的关系，内容区可能只是整个页面的一部分，需要使用calc() 函数计算一下高度：例如本例中收起全文状态时，.showSome的height为: calc(100vh-220px); 收起全文状态时，展开全文按钮及其周围部分遮挡了新闻详情的内容，并且有一个透明且渐变的效果。这里使用了background: linear-gradient这个属性，该属性规定了渐变的方向和不同节点的状态。123456789background: linear-gradient( to bottom, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0.35) 30%, rgba(255, 255, 255, 0.6) 40%, rgba(255, 255, 255, 0.8) 60%, rgba(255, 255, 255, 0.95) 70%, #ffffff 100% ); 附上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;div class=\"newsShare\"&gt; &lt;div class=\"newsShareMain\" :class=\"showAll===true?'showAll':'showSome'\"&gt; &lt;div class=\"topFloaBlock\"&gt; &lt;img class=\"logo\" src=\"https://dss2.bdstatic.com/6Ot1bjeh1BF3odCf/it/u=4217756273,752027184&amp;fm=74&amp;app=80&amp;f=JPEG&amp;size=f121,121?sec=1880279984&amp;t=a4ebf88698c50239adcaa199fa4e172b\" alt /&gt; &lt;div class=\"text\"&gt; &lt;div class=\"text1\"&gt;北高峰APP&lt;/div&gt; &lt;div class=\"text2\"&gt;下周北高峰APP查看更多&lt;/div&gt; &lt;/div&gt; &lt;div class=\"openBtn\"&gt;立即打开&lt;/div&gt; &lt;/div&gt; &lt;div class=\"title\"&gt;{{detailData.title}}&lt;/div&gt; &lt;div class=\"accountWrap\"&gt; &lt;div class=\"accountImgAndName\"&gt; &lt;img :src=\"detailData.accountAvatar\" alt /&gt; {{detailData.accountName}} &lt;/div&gt; &lt;div class=\"accountState\"&gt; &lt;div class=\"followBtn followBtn1\" v-if=\"detailData.accountState === 0\"&gt;+ 关注&lt;/div&gt; &lt;div class=\"followBtn followBtn2\" v-else&gt;已关注&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"timeAndReadnum\"&gt; {{detailData.time}} &lt;img src=\"../../assets/images/person.png\" class=\"iconPerson\" alt /&gt; {{detailData.readNum}} &lt;/div&gt; &lt;div class=\"content\" v-html=\"detailData.content\"&gt;&lt;/div&gt; &lt;div class=\"hiddenWrap\" v-if=\"showAll===true\"&gt; &lt;div @click=\"changeShow\" class=\"showAllBtn\"&gt;收起全文&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"showAllWrap\" v-if=\"showAll===false\"&gt; &lt;div @click=\"changeShow\" class=\"showAllBtn\"&gt;展开全文&lt;/div&gt; &lt;/div&gt; &lt;div class=\"bottomFloaBlock\"&gt;打开北高峰APP 查看更多精彩资讯&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415161718192021222324252627282930313233343536&lt;script&gt;export default { data() { return { comment: \"\", showAll: false, nowId: null, detailData: { title: \"中国政府准备惩戒美国一些个人和实体？中方回应\", accountName: \"浙江应急广播\", accountAvatar: \"https://dss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2164724814,1401845036&amp;fm=26&amp;gp=0.jpg\", accountState: 0, time: \"52分钟前\", readNum: 24786, content: '&lt;div style=\"font-size:17px;line-height:30px;\"&gt;' + '&lt;span style=\"font-weight:bold;\"&gt;【环球时报-环球网报道 记者 乌元春】&lt;/span&gt;' + \"长江网5月24日讯 5月15日武汉集中核酸检测启动以来，截至5月24日，已为900多万居民采样。为尽可能让从未做过核酸检测的居民都参加本次集中检测，5月23日起，武汉各区共设置了231个“查缺补漏”采样点，为之前因各种原因未能采样检测的居民提供补采服务。对老人、残疾人等特殊群体，医务人员上门为他们采样。\" + \"长江网5月24日讯 5月15日武汉集中核酸检测启动以来，截至5月24日，已为900多万居民采样。为尽可能让从未做过核酸检测的居民都参加本次集中检测，5月23日起，武汉各区共设置了231个“查缺补漏”采样点，为之前因各种原因未能采样检测的居民提供补采服务。对老人、残疾人等特殊群体，医务人员上门为他们采样。\" + '&lt;img style=\"margin:24px 0;\" src=\"https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1143438203,2101264949&amp;fm=26&amp;gp=0.jpg\" alt=\"\"&gt;' + \"5月15日武汉集中核酸检测启动以来，截至5月24日，已为900多万居民采样。为尽可能让从未做过核酸检测的居民都参加本次集中检测，5月23日起，武汉各区共设置了231个“查缺补漏”采样点，为之前因各种原因未能采样检测的居民提供补采服务。对老人、残疾人等特殊群体，医务人员上门为他们采样。\" + \"长江网5月24日讯 5月15日武汉集中核酸检测启动以来，截至5月24日，已为900多万居民采样。为尽可能让从未做过核酸检测的居民都参加本次集中检测，5月23日起，武汉各区共设置了231个“查缺补漏”采样点，为之前因各种原因未能采样检测的居民提供补采服务。对老人、残疾人等特殊群体，医务人员上门为他们采样。\" + '&lt;img style=\"margin:24px 0;\" src=\"https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1143438203,2101264949&amp;fm=26&amp;gp=0.jpg\" alt=\"\"&gt;' + \"5月15日武汉集中核酸检测启动以来，截至5月24日，已为900多万居民采样。为尽可能让从未做过核酸检测的居民都参加本次集中检测，5月23日起，武汉各区共设置了231个“查缺补漏”采样点，为之前因各种原因未能采样检测的居民提供补采服务。对老人、残疾人等特殊群体，医务人员上门为他们采样。\" + \"&lt;/div&gt;\" } }; }, methods: { changeShow() { this.showAll = !this.showAll; } }};&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179&lt;style lang=\"scss\"&gt;.newsShare { position: relative; .showAll { height: auto; } .showSome { height: calc(100vh-220px); overflow: hidden; } .newsShareMain { padding: 32px; padding-top: 174px; position: relative; color: #222222; background-color: #feffff; .title { font-size: 44px; line-height: 60px; font-weight: bold; margin-bottom: 28px; } .accountWrap { display: flex; justify-content: space-between; align-items: center; height: 40px; .accountImgAndName { font-size: 28px; line-height: 40px; img { width: 40px; height: 40px; border-radius: 20px; margin-right: 4px; } } .accountState { height: 100%; font-size: 26px; line-height: 40px; .followBtn { box-sizing: border-box; height: 42px; padding: 2px 10px; border-radius: 12px; line-height: 42px; } .followBtn1 { color: #ffffff; background-color: #4273ff; } .followBtn2 { color: #ffffff; background-color: #bbb; } } } .timeAndReadnum { color: #9b9b9b; font-size: 24px; line-height: 34px; margin: 16px 0 64px 0; display: flex; align-items: center; .iconPerson { display: inline-block; width: 30px; margin: 0 0 0 26px; } } .content { margin-bottom: 36px; } .hiddenWrap { padding-bottom: 100px; text-align: center; .showAllBtn { width: 196px; height: 56px; margin: auto; border: 1px solid #4273ff; border-radius: 28px; color: #4273ff; font-size: 26px; line-height: 56px; background-color: white; } } } .topFloaBlock { position: fixed; width: 686px; top: 0; height: 80px; display: flex; justify-content: space-between; align-items: center; padding-top: 32px; padding-bottom: 30px; border-bottom: 1px solid #efefef; margin-bottom: 32px; background-color: white; .logo { width: 78px; height: 78px; border-radius: 12px; } .text { flex: 1; margin-left: 12px; .text1 { font-size: 32px; color: #000000; line-height: 44px; font-weight: bold; } .text2 { font-size: 24px; color: #9b9b9b; line-height: 34px; } } .openBtn { width: 132px; height: 56px; background-color: #4273ff; border-radius: 12px; color: #ffffff; font-size: 26px; line-height: 56px; text-align: center; } } .bottomFloaBlock { position: fixed; bottom: 0; width: 100%; height: 100px; background-color: #4273ff; color: white; font-size: 38px; line-height: 100px; text-align: center; } .showAllWrap { position: fixed; bottom: 100px; width: 100%; height: 254px; box-sizing: border-box; padding-top: 134px; color: white; font-size: 38px; line-height: 100px; text-align: center; background: linear-gradient( to bottom, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0.35) 30%, rgba(255, 255, 255, 0.6) 40%, rgba(255, 255, 255, 0.8) 60%, rgba(255, 255, 255, 0.95) 70%, #ffffff 100% ); .showAllBtn { width: 196px; height: 56px; margin: auto; border: 1px solid #4273ff; border-radius: 28px; color: #4273ff; font-size: 26px; line-height: 56px; background-color: white; } }}&lt;/style&gt;","link":"/2020/05/09/blog21/"},{"title":"移动端适配方案：postcss-px-to-viewport","text":"做移动端的项目时，都会遇到适配相关的问题，例如微信公众号、手机端官网、APP的内嵌H5等。公司采用的解决方案是postcss-px-to-viewport，个人感觉这个方案使用起来超级简单，非常推荐。而且现在浏览器对viewport的支持越来越高，兼容性这方面也不需要担心。 顾名思义，postcss-px-to-viewport就是将px单位转化成viewport，来帮你解决不同设备间的适配问题。 安装： 1$ npm install postcss-px-to-viewport 在vue项目的根目录下新建一个配置文件postcss.config.js： postcss.config.js12345678910111213141516171819module.exports = { \"plugins\": { \"postcss-px-to-viewport\": { viewportWidth: 750, // 视窗的宽度，对应的是我们设计稿的宽度，一般是750 viewportHeight: 1334, // 视窗的高度，根据750设备的宽度来指定，一般指定1334，也可以不配置 unitPrecision: 3, // 指定`px`转换为视窗单位值的小数位数（很多时候无法整除） viewportUnit: 'vw', // 指定需要转换成的视窗单位，建议使用vw selectorBlackList: ['.ignore', '.hairlines','.van-',/^(.van)/,/^(.igno)/], // 指定不转换为视窗单位的类，可以自定义，可以无限添加,建议定义一至两个通用的类名 minPixelValue: 1, // 小于或等于`1px`不转换为视窗单位，你也可以设置为你想要的值 mediaQuery: false // 允许在媒体查询中转换`px` }, \"cssnano\": { preset: \"advanced\", autoprefixer: false, \"postcss-zindex\": false } }} 配置文件的各项参数含义都写在注释中了。","link":"/2020/05/17/blog22/"},{"title":"盘点一些常用的语法和知识点-HTML/CSS篇","text":"（持续更新中……）本文盘点了一些工作中会经常使用到的，或者是比较重要但是不太熟练的语法和知识点。 一、Flex 布局内容转自阮一峰的Flex 布局教程,不过个人觉得阮一峰老师教程页面的色调不是很利于阅读，于是在这里重构一下，仅供个人阅读使用。 123.box{ display: flex;} 常用属性 flex-direction决定主轴的方向（即项目的排列方向）。 123.box { flex-direction: row | row-reverse | column | column-reverse;} flex-wrap如果一条轴线排不下，如何换行。默认情况下，不换行 123.box{ flex-wrap: nowrap | wrap | wrap-reverse;} justify-content定义项目在主轴上的对齐方式。 123.box { justify-content: flex-start | flex-end | center | space-between | space-around;} align-items定义项目在交叉轴上如何对齐。 123.box { align-items: flex-start | flex-end | center | baseline | stretch;} align-content定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 123.box { align-content: flex-start | flex-end | center | space-between | space-around | stretch;} 二、子元素选择器：nth-child() 选择第n个子元素，n为数字:nth-child(n) 选择列表中的偶数子元素:nth-child(2n) 选择列表中的奇数子元素:nth-child(2n-1) 选择前n个子元素【负方向范围】选择第1个到第6个:nth-child(-n+6){} 从第n个子元素开始选择【正方向范围】选择从第6个开始的，直到最后:nth-child(n+6){} 两者结合使用，可以限制选择某个范围内的子元素【限制范围】选择第6个到第9个，取两者的交集:nth-child(-n+9):nth-child(n+6){} 选择列表中的倒数第n个子元素:nth-last-child(n) 例子： 123456/*给class=\"tagWrap\"的div的前三个.tag子元素加上右外边距 */.tagWrap { .tag:nth-child(-n + 3) { margin-right: 12px; }} 三、背景图片填充且居中12345.avatar { background-repeat: no-repeat; background-size: cover; background-position: center;} 四、背景渐变1234567891011.backDiv { background: linear-gradient( to bottom, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0.35) 30%, rgba(255, 255, 255, 0.6) 40%, rgba(255, 255, 255, 0.8) 60%, rgba(255, 255, 255, 0.95) 70%, #ffffff 100% );} 五、屏幕可见区域单位：vh类似于px的长度单位，100vh代表屏幕可见区域的100%，50vh代表屏幕可见区域的50%。 六、计算css的函数：calc() 函数例如 height: calc(100vh-220px) 表示高度为屏幕可见区域的100%减去220px。","link":"/2019/12/30/blog4/"},{"title":"常用的js数组方法","text":"本文系统的整理了工作中比较常用的数组方法。 一、数组检测方法 instanceof Array.isArray()（推荐）123let arr = [1,2,3,4];console.log(arr instanceof Array); // true console.log(Array.isArray(arr)); // true instanceof在跨多个 iframe（即多个全局执行环境）时会失效，Array.isArray()才是最终的解决办法。 二、数组操作方法（增删等） push()添加若干项到数组末尾，并返回修改后数组的长度。 pop()从数组末尾移除一项，减少数组的 length 值，然后返回移除的项（最后一项）。 unshift()添加若干项到数组前端，并返回修改后数组的长度。 shift()从数组前端移除一项，减少数组的 length 值，然后返回移除的项（第一项）。 concat()拼接数组，concat()的参数既可以接收一个数组，也可以接收非数组。concat()不会改变原数组，但是会返回拼接过的新数组 1234let arr1 = [\"red\", \"green\", \"blue\"]; let arr2 = colors.concat(\"yellow\", [\"black\", \"brown\"]);console.log(arr2) //打印结果：[\"red\", \"green\", \"blue\", \"yellow\", \"black\", \"brown\"]console.log(arr1) //打印结果：[\"red\", \"green\", \"blue\"] splice()splice()功能强大，可以实现增、删、改功能，接收的参数如下： 12345678910111213141516splice(index,num,newItem1,newItem2,......)//index：起始位置（数组索引）//num：要删除的项数//newItem1,newItem2,......：要插入的项//举例let arr = [1,2,3]//增arr.splice(1,0,'haha')console.log(arr) //打印结果：[1, \"haha\", 2, 3]//删arr.splice(1,1)console.log(arr) //打印结果：[1, 2, 3]//改arr.splice(1,1,'heihei')console.log(arr) //打印结果：[1, 'heihei', 3] 三、str和数组的互相转化 toString()、join() split()123456789101112//数组转字符串let arr1 = [1,2,3,4]let str1 = arr1.toString()let str2 = arr1.join('-')console.log(str1) //输出\"1,2,3,4\"console.log(str2) //输出\"1-2-3-4\"//字符串转数组let arr2 = str1.split(\",\")let arr3 = str2.split(\"-\")console.log(arr2) //输出[1,2,3,4]console.log(arr3) //输出[1,2,3,4] 四、位置方法 indexOf() lastIndexOf()1234let arr = [1,2,3,4,5,4,3,2,1]; console.log(arr.indexOf(4)); //输出3，只会返回第一个值为4的项的位置console.log(arr.lastIndexOf(2)); //输出7,不是1。虽然是从数组末尾开始计算位置，但也是从index=0开始查找的console.log(arr.indexOf(99)); //输出-1 arr.indexOf(‘item’)===-1常用来判断数组中是否存在某值 五、重排序方法 reverse()（翻转） sort() （排序，默认按字符串顺序升序）123let arr = [1, 2, 3, 4, 5]; arr.reverse();console.log(arr) //输出[5, 4, 3, 2, 1] reverse()方法会改变原数组。123let arr = [5, 0, 1, 15, 10]; arr.sort(); console.log(arr); //0,1,10,15,5 sort()方法也会改变原数组，默认情况下先调用每项的toString，然后比较得到的字符串，所以10排在5前面。这种排序方式在很多情况下都不是最佳方案。因此sort()方法可以接收一个比较函数作为参数，以便我们指定排序的规则。以下就是一个简单的比较函数：12345678910111213141516171819/*比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。*/function compare(value1, value2) { if (value1 &lt; value2) { return -1; } else if (value1 &gt; value2) { return 1; } else { return 0; } }let arr = [5, 0, 1, 15, 10]; arr.sort(compare);console.log(arr); //0,1,5,10,15 五、迭代方法 every()对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。 filter()对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。 forEach()对数组中的每一项运行给定函数。这个方法没有返回值。 map()对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 some()对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。 这些方法都接收3个参数，分别是 数组该项的值，该项的索引，原数组 1234let arr = [1,2,3]arr.forEach((val,index,arr) =&gt; { // 需要进行的操作}) 以上方法都不会修改数组中的包含的值，但可以自行在回调函数中写入操作数组的代码。","link":"/2019/12/26/blog3/"},{"title":"js日期对象Date和字符串的互相转化","text":"Date对象转换为指定格式的字符串，如：YYYY-mm-dd HH:MMYYYY-mm-dd等。一个Date对象123let now = new Date()console.log(now) //打印结果：Fri Jan 03 2020 10:05:48 GMT+0800 (中国标准时间) 定义格式化Date的方法format：123456789101112format(date,format){ let dateFormatStr = '' let year = date.getFullYear() let mouth = date.getMonth()+1 //Date对象中月份为0-11 let day = date.getDate() let hour = date.getHours() let min = date.getMinutes() let s = date.getSeconds() // 将format格式中的字符串替换 dateFormatStr = format.replace(/yyyy/, year).replace(/MM/, mouth).replace(/dd/, day).replace(/hh/, hour).replace(/mm/, min).replace(/ss/, s) return dateFormatStr} 对Date对象调用format方法:123let nowStr = this.format(now,'yyyy-MM-dd hh:mm:ss')console.log(nowStr) //打印结果：2020-1-1 10:5:48 对 format 方法传入不同的 format 参数，即可转换成不同格式。 字符串转换成Date对象1234567891011//传入字符串let date1 = new Date(\"2020-1-1\")let date2 = new Date(\"2020/1/1\")let date3 = new Date(\"2020,1,1\")//传入整数参数let date4 = new Date(2020,1,1)console.log(date3)//Wed Jan 01 2020 00:00:00 GMT+0800 (中国标准时间)console.log(date4)//Sat Feb 01 2020 00:00:00 GMT+0800 (中国标准时间) 注意：Date对象中月份是0-11，所以date4这样传入整数生成的Date对象代表2020年2月1日","link":"/2020/01/01/blog6/"},{"title":"发送手机验证码后按钮倒计时的功能","text":"工作中开发项目时，经常会用到手机验证码登录的功能，这里记录一下发送验证码后按钮倒计时的方法。 HTML123456789101112131415161718192021&lt;div class=\"p-from-group\"&gt; &lt;div class=\"p-input-item\"&gt; &lt;input placeholder=\"请输入手机号\" type=\"number\" v-model=\"phone\" /&gt; &lt;/div&gt; &lt;div class=\"p-input-item\"&gt; &lt;input placeholder=\"请输入验证码\" type=\"text\" /&gt; &lt;button :disabled=\"disabled\" @click=\"sendSMS\" class=\"p-btn\" &gt;{{codeTxt}}&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"p-btn-login\"&gt;登录&lt;/div&gt; JavaScript12345678910111213141516171819202122232425262728293031323334353637export default { data() { return { phone: '', codeTxt: \"获取验证码\", disabled: false, MAX_COUNT:10, count: 10, }; }, methods: { sendSMS() { //手机号正则验证 if (/^1[3456789]\\d{9}$/.test(this.phone)) { this.count = this.MAX_COUNT this.countDown() console.log('模拟请求验证码,code:2020') } else { console.log('请输入正确的手机号！') } }, // 按钮倒计时 countDown() { this.disabled = true this.codeTxt = `已发送（${this.count}s）` this.count-- setTimeout(() =&gt; { if (this.count &gt; 0) { this.countDown() }else if (this.count === 0) { this.disabled = false this.codeTxt = \"获取验证码\" } }, 1000); }, }}; 效果如下： 点击发送之后：","link":"/2019/12/31/blog5/"},{"title":"Ant Design of Vue 的表单自定义验证规则","text":"公司的后台项目使用的UI库是Ant Design。在工作中，由于Ant Design表单From提供的验证方式比较单一，经常会用到表单的自定义验证，这里总结一下基本的用法。 123456789101112131415161718192021222324&lt;a-input type=\"number\" v-decorator=\"['saleCost', { rules: [ { required: true, message: '请输入金额！'}, { validator: validatorCost } ]}]\"/&gt;methods: { validatorCost(rule, value, callback) { var reg = /^(?:0\\.\\d{0,1}[1-9]|(?!0)\\d{1,8}(?:\\.\\d{0,1}[1-9])?)$/; if (!value||value === '') { // 不填写金额时，希望走 required: true 的验证，所以自定义验证这边要通过，不然会报两次 callback(); // 如果去掉 required: true 的验证，则这里可以写 callback('请输入金额！'); } else if (!reg.test(value)) { callback('请输入正确的金额格式！'); //验证不通过 } else if (value &gt; 10000) { callback('金额不得超过10000！'); //验证不通过 } else { callback(); //验证通过 } },}","link":"/2020/01/08/blog9/"},{"title":"从零开始使用Vue Router","text":"公司项目大都是在已经搭建好的模板上进行开发，加上自己也没有认真梳理过，导致工作大半年了对vue-router还是不太熟练，每次使用都要看文档。这次趁着有时间，在这里系统地梳理一下相关内容，从零开始过一遍。 首先创建一个vue项目，然后安装vue-router。 NPM 1npm install vue-router Yarn 1yarn add vue-router 建议使用Yarn，安装速度更快更稳定。npm可能会出现由于速度慢连接不稳定而导致的下载文件缺失导致项目运行失败。 开始使用首先在src/components中新建foo.vue和bar.vue两个文件，作为路由显示的页面内容。然后在src目录下新建一个router.js文件，写入以下内容： router.js123456789101112131415161718192021222324252627// 引入Vue和VueRouterimport Vue from 'vue'import VueRouter from 'vue-router'// 引入（路由）组件import Foo from './components/foo.vue'import Bar from './components/bar.vue'// 告诉 Vue 使用 VueRouterVue.use(VueRouter)// 定义路由routerconst router = new VueRouter({ routes: [ { path: '/foo', component: Foo }, { path: '/bar', component: Bar }, ]});// 将router暴露出去供其他文件使用export default router; 此时项目的目录结构为： 在main.js中引入router.js文件： main.js12345678910import Vue from 'vue'import App from './App.vue'import router from './router'Vue.config.productionTip = falsenew Vue({ router,// 将路由注入到根实例中 render: h =&gt; h(App),}).$mount('#app') 在App.vue中添加router-link和router-view： App.vue12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div id=\"app\"&gt; &lt;h1&gt;Hello VueRouter!&lt;/h1&gt; &lt;div&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to=\"/foo\"&gt;Go to Foo&lt;/router-link&gt; &lt;router-link to=\"/bar\"&gt;Go to Bar&lt;/router-link&gt; &lt;/div&gt; &lt;!-- 路由出口 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { name: 'app', components: { } }&lt;/script&gt;&lt;style&gt; #app { text-align: center; margin-top: 60px; } a { margin-right: 16px; text-decoration: none; }&lt;/style&gt; 运行项目，效果如下，点击页面上的router-link可以切换显示对应的router组件： 但是当首次进入页面的时候，router-view中并没有显示任何内容。这是因为首次进入页面时，它的路径是/，我们并没有给这个路径做相应的配置。我们可以在router.js中添加一项路由，给空路径/指定一个组件， 1234{ path: '/', component: Foo} 或者是给空路径/重定向一个其他的路径，（建议使用这种方式） 1234{ path: '/', component: Foo} 修改之后router.js内容如下： router.js1234567891011121314151617181920212223242526272829303132333435// 引入Vue和VueRouterimport Vue from 'vue'import VueRouter from 'vue-router'// 引入（路由）组件import Foo from './components/foo.vue'import Bar from './components/bar.vue'// 告诉 Vue 使用 VueRouterVue.use(VueRouter)// 定义路由routerconst router = new VueRouter({ routes: [ // { // path: '/', // component: Foo // }, { path: '/', redirect: '/foo' }, { path: '/foo', component: Foo }, { path: '/bar', component: Bar }, ]});// 将router暴露出去供其他文件使用export default router; 嵌套路由App.vue中的router-view是最顶层的出口，渲染最高级路由匹配到的组件。同样的，一个被渲染组件同样可以包含自己的嵌套router-view。 例如，在 Bar 组件的模板添加一个 router-view ，其中包含 BarChild1 和 BarChild2 两个子组件。 在 src/components 目录下新建 bar-child1.vue 和 bar-child2.vue 两个文件，然后将 bar.vue 和 router.js 修改成如下内容： bar.vue123456789101112&lt;template&gt; &lt;div style=\"margin:33px;\"&gt; 这里是bar &lt;div&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link :to=\"{name:'BarChild1'}\"&gt;Go to bar-child1&lt;/router-link&gt; &lt;router-link :to=\"{name:'BarChild2'}\"&gt;Go to bar-child2&lt;/router-link&gt; &lt;/div&gt; &lt;!-- 路由出口 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; router.js1234567891011121314151617181920212223242526272829303132333435363738394041import Vue from 'vue'import VueRouter from 'vue-router'import Foo from './components/foo.vue'import Bar from './components/bar.vue'import BarChild1 from './components/bar-child1.vue'import BarChild2 from './components/bar-child2.vue'Vue.use(VueRouter)const router = new VueRouter({ routes: [{ path: '/', redirect: '/foo' }, { path: '/foo', component: Foo, name: 'Foo' }, { path: '/bar', component: Bar, name: 'Bar', children: [{ path: 'bar-child1', component: BarChild1, name: 'BarChild1', }, { path: 'bar-child2', component: BarChild2, name: 'BarChild2', }, ] }, ]});export default router; 为了方便使用，我们在定义路由的时候加上了name字段，在router-link中，我们可以使用对象来代替之前的路径了。 运行效果如下： 要注意，以 / 开头的嵌套路径会被当作根路径。 这让你充分的使用嵌套组件而无须设置嵌套的路径。例如，当 router.js 中 BarChild1 组件的路由path是这样时： 12345{ path: 'bar-child1', component: BarChild1, name: 'BarChild1',} BarChild1 在浏览器地址栏的路径是：localhost:8080/#/bar/bar-child1。 而当 BarChild1 组件的路由path是以/开头时： 12345{ path: '/bar-child1', component: BarChild1, name: 'BarChild1',} BarChild1 在浏览器地址栏的路径是：localhost:8080/#/bar-child1。 路由元信息工作中，我们常常还会为路由定义一些自定义属性，这些属性我们可以放在meta字段（路由元信息）中： 1234567891011{ path: '/home', component: Home, name: 'Home', meta: { name: '主页', isShow: true, requiresAuth: true, ...... }}, 可以通过this.$router.meta[属性名]拿到对应的值。 编程式的导航除了通过router-link来创建导航链接外，我们还可以借助router的实例方法，通过js代码来实现。将App.vue中的router-link修改为button，通过添加点击事件方法同样可以完成路由的切换。 App.vue1234567891011&lt;template&gt; &lt;div id=\"app\"&gt; &lt;h1&gt;Hello VueRouter!&lt;/h1&gt; &lt;div&gt; &lt;router-link to=\"/foo\"&gt;Go to Foo&lt;/router-link&gt; &lt;button @click=\"goPage('Bar')\"&gt;Go to Bar&lt;/button&gt; &lt;/div&gt; &lt;!-- 路由出口 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112export default { name: 'app', components: { }, methods: { goPage(routerName) { this.$router.push({ name: routerName }) } }} 效果如下： Vue Router 的基本使用就是这样了，更加复杂的使用可以看：使用Vue搭建后台管理系统。","link":"/2020/01/06/blog7/"},{"title":"js实现根据sku关键属性算出所有sku的算法","text":"最近在公司做了一个商品中台的项目，商品模块中一个比较基础的部分是根据sku的关键属性算出所有sku组合的需求，在这里记录一下当时用到的算法： 首先我们可以拿到后端返回的sku关键属性 12345678910let skuKey = [ { name:\"颜色\", value:[\"黑色\",\"白色\"] }, { name:\"内存\", value:[\"64g\",\"128g\",\"256g\"] },] 现在我们需要根据这个skuKey生成sku组合。 先把这个skuKey处理成一个二维数组的格式： 12345678let twoDimensionalArray = []forEach((item,index) =&gt; { twoDimensionalArray.push(item.value)})// twoDimensionalArray = [// [\"黑色\",\"白色\"],// [\"64g\",\"128g\",\"256g\"],// ]; 求组合： 1234567891011121314function cartesianProductOf() { return Array.prototype.reduce.call(arguments,function(a, b) { var ret = []; a.forEach(function(a) { b.forEach(function(b) { ret.push(a.concat([b])); }); }); return ret; }, [[]]);} let combination =cartesianProductOf(...twoDimensionalArray )console.log(combination) combination结果为： 12345678[ [\"黑色\", \"64g\"], [\"黑色\", \"128g\"], [\"黑色\", \"256g\"], [\"白色\", \"64g\"], [\"白色\", \"128g\"], [\"白色\", \"256g\"],]","link":"/2020/01/08/blog8/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"Ant Design","slug":"Ant-Design","link":"/tags/Ant-Design/"},{"name":"Vue Router","slug":"Vue-Router","link":"/tags/Vue-Router/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"常用","slug":"常用","link":"/tags/%E5%B8%B8%E7%94%A8/"},{"name":"sass","slug":"sass","link":"/tags/sass/"},{"name":"Axios","slug":"Axios","link":"/tags/Axios/"},{"name":"Vuex","slug":"Vuex","link":"/tags/Vuex/"},{"name":"闭包","slug":"闭包","link":"/tags/%E9%97%AD%E5%8C%85/"},{"name":"vuedraggable","slug":"vuedraggable","link":"/tags/vuedraggable/"},{"name":"拖拽","slug":"拖拽","link":"/tags/%E6%8B%96%E6%8B%BD/"},{"name":"es6/7","slug":"es6-7","link":"/tags/es6-7/"},{"name":"Echarts","slug":"Echarts","link":"/tags/Echarts/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"H5","slug":"H5","link":"/tags/H5/"},{"name":"移动端","slug":"移动端","link":"/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Ant Design","slug":"Ant-Design","link":"/categories/Ant-Design/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"Vue Router","slug":"Vue/Vue-Router","link":"/categories/Vue/Vue-Router/"},{"name":"Axios","slug":"Vue/Axios","link":"/categories/Vue/Axios/"},{"name":"es6/7","slug":"es6-7","link":"/categories/es6-7/"},{"name":"Echarts","slug":"Echarts","link":"/categories/Echarts/"},{"name":"HTML","slug":"HTML","link":"/categories/HTML/"},{"name":"H5","slug":"H5","link":"/categories/H5/"},{"name":"Vuex","slug":"Vue/Vuex","link":"/categories/Vue/Vuex/"},{"name":"CSS","slug":"HTML/CSS","link":"/categories/HTML/CSS/"}]}